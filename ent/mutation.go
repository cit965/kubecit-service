// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"kubecit-service/ent/category"
	"kubecit-service/ent/course"
	"kubecit-service/ent/member"
	"kubecit-service/ent/predicate"
	"kubecit-service/ent/slider"
	"kubecit-service/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCategory = "Category"
	TypeCourse   = "Course"
	TypeMember   = "Member"
	TypeSlider   = "Slider"
	TypeToken    = "Token"
	TypeUser     = "User"
)

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op            Op
	typ           string
	id            *string
	name          *string
	parentId      *string
	level         *string
	status        *string
	clearedFields map[string]struct{}
	course        map[string]struct{}
	removedcourse map[string]struct{}
	clearedcourse bool
	done          bool
	oldValue      func(context.Context) (*Category, error)
	predicates    []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id string) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Category entities.
func (m *CategoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetParentId sets the "parentId" field.
func (m *CategoryMutation) SetParentId(s string) {
	m.parentId = &s
}

// ParentId returns the value of the "parentId" field in the mutation.
func (m *CategoryMutation) ParentId() (r string, exists bool) {
	v := m.parentId
	if v == nil {
		return
	}
	return *v, true
}

// OldParentId returns the old "parentId" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentId: %w", err)
	}
	return oldValue.ParentId, nil
}

// ResetParentId resets all changes to the "parentId" field.
func (m *CategoryMutation) ResetParentId() {
	m.parentId = nil
}

// SetLevel sets the "level" field.
func (m *CategoryMutation) SetLevel(s string) {
	m.level = &s
}

// Level returns the value of the "level" field in the mutation.
func (m *CategoryMutation) Level() (r string, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel resets all changes to the "level" field.
func (m *CategoryMutation) ResetLevel() {
	m.level = nil
}

// SetStatus sets the "status" field.
func (m *CategoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *CategoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CategoryMutation) ResetStatus() {
	m.status = nil
}

// AddCourseIDs adds the "course" edge to the Course entity by ids.
func (m *CategoryMutation) AddCourseIDs(ids ...string) {
	if m.course == nil {
		m.course = make(map[string]struct{})
	}
	for i := range ids {
		m.course[ids[i]] = struct{}{}
	}
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *CategoryMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *CategoryMutation) CourseCleared() bool {
	return m.clearedcourse
}

// RemoveCourseIDs removes the "course" edge to the Course entity by IDs.
func (m *CategoryMutation) RemoveCourseIDs(ids ...string) {
	if m.removedcourse == nil {
		m.removedcourse = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.course, ids[i])
		m.removedcourse[ids[i]] = struct{}{}
	}
}

// RemovedCourse returns the removed IDs of the "course" edge to the Course entity.
func (m *CategoryMutation) RemovedCourseIDs() (ids []string) {
	for id := range m.removedcourse {
		ids = append(ids, id)
	}
	return
}

// CourseIDs returns the "course" edge IDs in the mutation.
func (m *CategoryMutation) CourseIDs() (ids []string) {
	for id := range m.course {
		ids = append(ids, id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *CategoryMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
	m.removedcourse = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.parentId != nil {
		fields = append(fields, category.FieldParentId)
	}
	if m.level != nil {
		fields = append(fields, category.FieldLevel)
	}
	if m.status != nil {
		fields = append(fields, category.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	case category.FieldParentId:
		return m.ParentId()
	case category.FieldLevel:
		return m.Level()
	case category.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldParentId:
		return m.OldParentId(ctx)
	case category.FieldLevel:
		return m.OldLevel(ctx)
	case category.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldParentId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentId(v)
		return nil
	case category.FieldLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case category.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldParentId:
		m.ResetParentId()
		return nil
	case category.FieldLevel:
		m.ResetLevel()
		return nil
	case category.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.course != nil {
		edges = append(edges, category.EdgeCourse)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.course))
		for id := range m.course {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcourse != nil {
		edges = append(edges, category.EdgeCourse)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCourse:
		ids := make([]ent.Value, 0, len(m.removedcourse))
		for id := range m.removedcourse {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcourse {
		edges = append(edges, category.EdgeCourse)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeCourse:
		return m.clearedcourse
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeCourse:
		m.ResetCourse()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// CourseMutation represents an operation that mutates the Course nodes in the graph.
type CourseMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	isRecommend          *bool
	isIntegral           *bool
	saleType             *int32
	addsaleType          *int32
	discountPrice        *float32
	adddiscountPrice     *float32
	teachingType         *int32
	addteachingType      *int32
	courseLevel          *int32
	addcourseLevel       *int32
	updateBy             *time.Time
	lecturerName         *string
	purchaseCnt          *int32
	addpurchaseCnt       *int32
	totalHour            *float32
	addtotalHour         *float32
	bizCourseDetail      *string
	courseCover          *string
	bizCourseChapters    *string
	salePrice            *float32
	addsalePrice         *float32
	bizCourseTeacher     *string
	bizCourseAttachments *string
	updateTime           *time.Time
	tags                 *string
	courseName           *string
	createBy             *string
	purchaseCounter      *int32
	addpurchaseCounter   *int32
	createTime           *time.Time
	clicks               *int32
	addclicks            *int32
	status               *string
	clearedFields        map[string]struct{}
	categories           map[string]struct{}
	removedcategories    map[string]struct{}
	clearedcategories    bool
	done                 bool
	oldValue             func(context.Context) (*Course, error)
	predicates           []predicate.Course
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows management of the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for the Course entity.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the ID field of the mutation.
func withCourseID(id string) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Course entities.
func (m *CourseMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Course.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetIsRecommend sets the "isRecommend" field.
func (m *CourseMutation) SetIsRecommend(b bool) {
	m.isRecommend = &b
}

// IsRecommend returns the value of the "isRecommend" field in the mutation.
func (m *CourseMutation) IsRecommend() (r bool, exists bool) {
	v := m.isRecommend
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRecommend returns the old "isRecommend" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldIsRecommend(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRecommend is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRecommend requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRecommend: %w", err)
	}
	return oldValue.IsRecommend, nil
}

// ResetIsRecommend resets all changes to the "isRecommend" field.
func (m *CourseMutation) ResetIsRecommend() {
	m.isRecommend = nil
}

// SetIsIntegral sets the "isIntegral" field.
func (m *CourseMutation) SetIsIntegral(b bool) {
	m.isIntegral = &b
}

// IsIntegral returns the value of the "isIntegral" field in the mutation.
func (m *CourseMutation) IsIntegral() (r bool, exists bool) {
	v := m.isIntegral
	if v == nil {
		return
	}
	return *v, true
}

// OldIsIntegral returns the old "isIntegral" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldIsIntegral(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsIntegral is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsIntegral requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsIntegral: %w", err)
	}
	return oldValue.IsIntegral, nil
}

// ResetIsIntegral resets all changes to the "isIntegral" field.
func (m *CourseMutation) ResetIsIntegral() {
	m.isIntegral = nil
}

// SetSaleType sets the "saleType" field.
func (m *CourseMutation) SetSaleType(i int32) {
	m.saleType = &i
	m.addsaleType = nil
}

// SaleType returns the value of the "saleType" field in the mutation.
func (m *CourseMutation) SaleType() (r int32, exists bool) {
	v := m.saleType
	if v == nil {
		return
	}
	return *v, true
}

// OldSaleType returns the old "saleType" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldSaleType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaleType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaleType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaleType: %w", err)
	}
	return oldValue.SaleType, nil
}

// AddSaleType adds i to the "saleType" field.
func (m *CourseMutation) AddSaleType(i int32) {
	if m.addsaleType != nil {
		*m.addsaleType += i
	} else {
		m.addsaleType = &i
	}
}

// AddedSaleType returns the value that was added to the "saleType" field in this mutation.
func (m *CourseMutation) AddedSaleType() (r int32, exists bool) {
	v := m.addsaleType
	if v == nil {
		return
	}
	return *v, true
}

// ResetSaleType resets all changes to the "saleType" field.
func (m *CourseMutation) ResetSaleType() {
	m.saleType = nil
	m.addsaleType = nil
}

// SetDiscountPrice sets the "discountPrice" field.
func (m *CourseMutation) SetDiscountPrice(f float32) {
	m.discountPrice = &f
	m.adddiscountPrice = nil
}

// DiscountPrice returns the value of the "discountPrice" field in the mutation.
func (m *CourseMutation) DiscountPrice() (r float32, exists bool) {
	v := m.discountPrice
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountPrice returns the old "discountPrice" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldDiscountPrice(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountPrice: %w", err)
	}
	return oldValue.DiscountPrice, nil
}

// AddDiscountPrice adds f to the "discountPrice" field.
func (m *CourseMutation) AddDiscountPrice(f float32) {
	if m.adddiscountPrice != nil {
		*m.adddiscountPrice += f
	} else {
		m.adddiscountPrice = &f
	}
}

// AddedDiscountPrice returns the value that was added to the "discountPrice" field in this mutation.
func (m *CourseMutation) AddedDiscountPrice() (r float32, exists bool) {
	v := m.adddiscountPrice
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscountPrice resets all changes to the "discountPrice" field.
func (m *CourseMutation) ResetDiscountPrice() {
	m.discountPrice = nil
	m.adddiscountPrice = nil
}

// SetTeachingType sets the "teachingType" field.
func (m *CourseMutation) SetTeachingType(i int32) {
	m.teachingType = &i
	m.addteachingType = nil
}

// TeachingType returns the value of the "teachingType" field in the mutation.
func (m *CourseMutation) TeachingType() (r int32, exists bool) {
	v := m.teachingType
	if v == nil {
		return
	}
	return *v, true
}

// OldTeachingType returns the old "teachingType" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldTeachingType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTeachingType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTeachingType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTeachingType: %w", err)
	}
	return oldValue.TeachingType, nil
}

// AddTeachingType adds i to the "teachingType" field.
func (m *CourseMutation) AddTeachingType(i int32) {
	if m.addteachingType != nil {
		*m.addteachingType += i
	} else {
		m.addteachingType = &i
	}
}

// AddedTeachingType returns the value that was added to the "teachingType" field in this mutation.
func (m *CourseMutation) AddedTeachingType() (r int32, exists bool) {
	v := m.addteachingType
	if v == nil {
		return
	}
	return *v, true
}

// ResetTeachingType resets all changes to the "teachingType" field.
func (m *CourseMutation) ResetTeachingType() {
	m.teachingType = nil
	m.addteachingType = nil
}

// SetCourseLevel sets the "courseLevel" field.
func (m *CourseMutation) SetCourseLevel(i int32) {
	m.courseLevel = &i
	m.addcourseLevel = nil
}

// CourseLevel returns the value of the "courseLevel" field in the mutation.
func (m *CourseMutation) CourseLevel() (r int32, exists bool) {
	v := m.courseLevel
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseLevel returns the old "courseLevel" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCourseLevel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseLevel: %w", err)
	}
	return oldValue.CourseLevel, nil
}

// AddCourseLevel adds i to the "courseLevel" field.
func (m *CourseMutation) AddCourseLevel(i int32) {
	if m.addcourseLevel != nil {
		*m.addcourseLevel += i
	} else {
		m.addcourseLevel = &i
	}
}

// AddedCourseLevel returns the value that was added to the "courseLevel" field in this mutation.
func (m *CourseMutation) AddedCourseLevel() (r int32, exists bool) {
	v := m.addcourseLevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetCourseLevel resets all changes to the "courseLevel" field.
func (m *CourseMutation) ResetCourseLevel() {
	m.courseLevel = nil
	m.addcourseLevel = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *CourseMutation) SetUpdateBy(t time.Time) {
	m.updateBy = &t
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *CourseMutation) UpdateBy() (r time.Time, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldUpdateBy(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *CourseMutation) ResetUpdateBy() {
	m.updateBy = nil
}

// SetLecturerName sets the "lecturerName" field.
func (m *CourseMutation) SetLecturerName(s string) {
	m.lecturerName = &s
}

// LecturerName returns the value of the "lecturerName" field in the mutation.
func (m *CourseMutation) LecturerName() (r string, exists bool) {
	v := m.lecturerName
	if v == nil {
		return
	}
	return *v, true
}

// OldLecturerName returns the old "lecturerName" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldLecturerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLecturerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLecturerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLecturerName: %w", err)
	}
	return oldValue.LecturerName, nil
}

// ResetLecturerName resets all changes to the "lecturerName" field.
func (m *CourseMutation) ResetLecturerName() {
	m.lecturerName = nil
}

// SetPurchaseCnt sets the "purchaseCnt" field.
func (m *CourseMutation) SetPurchaseCnt(i int32) {
	m.purchaseCnt = &i
	m.addpurchaseCnt = nil
}

// PurchaseCnt returns the value of the "purchaseCnt" field in the mutation.
func (m *CourseMutation) PurchaseCnt() (r int32, exists bool) {
	v := m.purchaseCnt
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseCnt returns the old "purchaseCnt" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldPurchaseCnt(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseCnt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseCnt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseCnt: %w", err)
	}
	return oldValue.PurchaseCnt, nil
}

// AddPurchaseCnt adds i to the "purchaseCnt" field.
func (m *CourseMutation) AddPurchaseCnt(i int32) {
	if m.addpurchaseCnt != nil {
		*m.addpurchaseCnt += i
	} else {
		m.addpurchaseCnt = &i
	}
}

// AddedPurchaseCnt returns the value that was added to the "purchaseCnt" field in this mutation.
func (m *CourseMutation) AddedPurchaseCnt() (r int32, exists bool) {
	v := m.addpurchaseCnt
	if v == nil {
		return
	}
	return *v, true
}

// ResetPurchaseCnt resets all changes to the "purchaseCnt" field.
func (m *CourseMutation) ResetPurchaseCnt() {
	m.purchaseCnt = nil
	m.addpurchaseCnt = nil
}

// SetTotalHour sets the "totalHour" field.
func (m *CourseMutation) SetTotalHour(f float32) {
	m.totalHour = &f
	m.addtotalHour = nil
}

// TotalHour returns the value of the "totalHour" field in the mutation.
func (m *CourseMutation) TotalHour() (r float32, exists bool) {
	v := m.totalHour
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalHour returns the old "totalHour" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldTotalHour(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalHour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalHour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalHour: %w", err)
	}
	return oldValue.TotalHour, nil
}

// AddTotalHour adds f to the "totalHour" field.
func (m *CourseMutation) AddTotalHour(f float32) {
	if m.addtotalHour != nil {
		*m.addtotalHour += f
	} else {
		m.addtotalHour = &f
	}
}

// AddedTotalHour returns the value that was added to the "totalHour" field in this mutation.
func (m *CourseMutation) AddedTotalHour() (r float32, exists bool) {
	v := m.addtotalHour
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalHour resets all changes to the "totalHour" field.
func (m *CourseMutation) ResetTotalHour() {
	m.totalHour = nil
	m.addtotalHour = nil
}

// SetBizCourseDetail sets the "bizCourseDetail" field.
func (m *CourseMutation) SetBizCourseDetail(s string) {
	m.bizCourseDetail = &s
}

// BizCourseDetail returns the value of the "bizCourseDetail" field in the mutation.
func (m *CourseMutation) BizCourseDetail() (r string, exists bool) {
	v := m.bizCourseDetail
	if v == nil {
		return
	}
	return *v, true
}

// OldBizCourseDetail returns the old "bizCourseDetail" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldBizCourseDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizCourseDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizCourseDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizCourseDetail: %w", err)
	}
	return oldValue.BizCourseDetail, nil
}

// ResetBizCourseDetail resets all changes to the "bizCourseDetail" field.
func (m *CourseMutation) ResetBizCourseDetail() {
	m.bizCourseDetail = nil
}

// SetCourseCover sets the "courseCover" field.
func (m *CourseMutation) SetCourseCover(s string) {
	m.courseCover = &s
}

// CourseCover returns the value of the "courseCover" field in the mutation.
func (m *CourseMutation) CourseCover() (r string, exists bool) {
	v := m.courseCover
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseCover returns the old "courseCover" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCourseCover(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseCover: %w", err)
	}
	return oldValue.CourseCover, nil
}

// ResetCourseCover resets all changes to the "courseCover" field.
func (m *CourseMutation) ResetCourseCover() {
	m.courseCover = nil
}

// SetBizCourseChapters sets the "bizCourseChapters" field.
func (m *CourseMutation) SetBizCourseChapters(s string) {
	m.bizCourseChapters = &s
}

// BizCourseChapters returns the value of the "bizCourseChapters" field in the mutation.
func (m *CourseMutation) BizCourseChapters() (r string, exists bool) {
	v := m.bizCourseChapters
	if v == nil {
		return
	}
	return *v, true
}

// OldBizCourseChapters returns the old "bizCourseChapters" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldBizCourseChapters(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizCourseChapters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizCourseChapters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizCourseChapters: %w", err)
	}
	return oldValue.BizCourseChapters, nil
}

// ResetBizCourseChapters resets all changes to the "bizCourseChapters" field.
func (m *CourseMutation) ResetBizCourseChapters() {
	m.bizCourseChapters = nil
}

// SetSalePrice sets the "salePrice" field.
func (m *CourseMutation) SetSalePrice(f float32) {
	m.salePrice = &f
	m.addsalePrice = nil
}

// SalePrice returns the value of the "salePrice" field in the mutation.
func (m *CourseMutation) SalePrice() (r float32, exists bool) {
	v := m.salePrice
	if v == nil {
		return
	}
	return *v, true
}

// OldSalePrice returns the old "salePrice" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldSalePrice(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalePrice: %w", err)
	}
	return oldValue.SalePrice, nil
}

// AddSalePrice adds f to the "salePrice" field.
func (m *CourseMutation) AddSalePrice(f float32) {
	if m.addsalePrice != nil {
		*m.addsalePrice += f
	} else {
		m.addsalePrice = &f
	}
}

// AddedSalePrice returns the value that was added to the "salePrice" field in this mutation.
func (m *CourseMutation) AddedSalePrice() (r float32, exists bool) {
	v := m.addsalePrice
	if v == nil {
		return
	}
	return *v, true
}

// ResetSalePrice resets all changes to the "salePrice" field.
func (m *CourseMutation) ResetSalePrice() {
	m.salePrice = nil
	m.addsalePrice = nil
}

// SetBizCourseTeacher sets the "bizCourseTeacher" field.
func (m *CourseMutation) SetBizCourseTeacher(s string) {
	m.bizCourseTeacher = &s
}

// BizCourseTeacher returns the value of the "bizCourseTeacher" field in the mutation.
func (m *CourseMutation) BizCourseTeacher() (r string, exists bool) {
	v := m.bizCourseTeacher
	if v == nil {
		return
	}
	return *v, true
}

// OldBizCourseTeacher returns the old "bizCourseTeacher" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldBizCourseTeacher(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizCourseTeacher is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizCourseTeacher requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizCourseTeacher: %w", err)
	}
	return oldValue.BizCourseTeacher, nil
}

// ResetBizCourseTeacher resets all changes to the "bizCourseTeacher" field.
func (m *CourseMutation) ResetBizCourseTeacher() {
	m.bizCourseTeacher = nil
}

// SetBizCourseAttachments sets the "bizCourseAttachments" field.
func (m *CourseMutation) SetBizCourseAttachments(s string) {
	m.bizCourseAttachments = &s
}

// BizCourseAttachments returns the value of the "bizCourseAttachments" field in the mutation.
func (m *CourseMutation) BizCourseAttachments() (r string, exists bool) {
	v := m.bizCourseAttachments
	if v == nil {
		return
	}
	return *v, true
}

// OldBizCourseAttachments returns the old "bizCourseAttachments" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldBizCourseAttachments(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBizCourseAttachments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBizCourseAttachments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBizCourseAttachments: %w", err)
	}
	return oldValue.BizCourseAttachments, nil
}

// ResetBizCourseAttachments resets all changes to the "bizCourseAttachments" field.
func (m *CourseMutation) ResetBizCourseAttachments() {
	m.bizCourseAttachments = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *CourseMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *CourseMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *CourseMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// SetTags sets the "tags" field.
func (m *CourseMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *CourseMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *CourseMutation) ResetTags() {
	m.tags = nil
}

// SetCourseName sets the "courseName" field.
func (m *CourseMutation) SetCourseName(s string) {
	m.courseName = &s
}

// CourseName returns the value of the "courseName" field in the mutation.
func (m *CourseMutation) CourseName() (r string, exists bool) {
	v := m.courseName
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseName returns the old "courseName" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCourseName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseName: %w", err)
	}
	return oldValue.CourseName, nil
}

// ResetCourseName resets all changes to the "courseName" field.
func (m *CourseMutation) ResetCourseName() {
	m.courseName = nil
}

// SetCreateBy sets the "createBy" field.
func (m *CourseMutation) SetCreateBy(s string) {
	m.createBy = &s
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *CourseMutation) CreateBy() (r string, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCreateBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *CourseMutation) ResetCreateBy() {
	m.createBy = nil
}

// SetPurchaseCounter sets the "purchaseCounter" field.
func (m *CourseMutation) SetPurchaseCounter(i int32) {
	m.purchaseCounter = &i
	m.addpurchaseCounter = nil
}

// PurchaseCounter returns the value of the "purchaseCounter" field in the mutation.
func (m *CourseMutation) PurchaseCounter() (r int32, exists bool) {
	v := m.purchaseCounter
	if v == nil {
		return
	}
	return *v, true
}

// OldPurchaseCounter returns the old "purchaseCounter" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldPurchaseCounter(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPurchaseCounter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPurchaseCounter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPurchaseCounter: %w", err)
	}
	return oldValue.PurchaseCounter, nil
}

// AddPurchaseCounter adds i to the "purchaseCounter" field.
func (m *CourseMutation) AddPurchaseCounter(i int32) {
	if m.addpurchaseCounter != nil {
		*m.addpurchaseCounter += i
	} else {
		m.addpurchaseCounter = &i
	}
}

// AddedPurchaseCounter returns the value that was added to the "purchaseCounter" field in this mutation.
func (m *CourseMutation) AddedPurchaseCounter() (r int32, exists bool) {
	v := m.addpurchaseCounter
	if v == nil {
		return
	}
	return *v, true
}

// ResetPurchaseCounter resets all changes to the "purchaseCounter" field.
func (m *CourseMutation) ResetPurchaseCounter() {
	m.purchaseCounter = nil
	m.addpurchaseCounter = nil
}

// SetCreateTime sets the "createTime" field.
func (m *CourseMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *CourseMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *CourseMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetClicks sets the "clicks" field.
func (m *CourseMutation) SetClicks(i int32) {
	m.clicks = &i
	m.addclicks = nil
}

// Clicks returns the value of the "clicks" field in the mutation.
func (m *CourseMutation) Clicks() (r int32, exists bool) {
	v := m.clicks
	if v == nil {
		return
	}
	return *v, true
}

// OldClicks returns the old "clicks" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldClicks(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClicks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClicks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClicks: %w", err)
	}
	return oldValue.Clicks, nil
}

// AddClicks adds i to the "clicks" field.
func (m *CourseMutation) AddClicks(i int32) {
	if m.addclicks != nil {
		*m.addclicks += i
	} else {
		m.addclicks = &i
	}
}

// AddedClicks returns the value that was added to the "clicks" field in this mutation.
func (m *CourseMutation) AddedClicks() (r int32, exists bool) {
	v := m.addclicks
	if v == nil {
		return
	}
	return *v, true
}

// ResetClicks resets all changes to the "clicks" field.
func (m *CourseMutation) ResetClicks() {
	m.clicks = nil
	m.addclicks = nil
}

// SetStatus sets the "status" field.
func (m *CourseMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *CourseMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CourseMutation) ResetStatus() {
	m.status = nil
}

// AddCategoryIDs adds the "categories" edge to the Category entity by ids.
func (m *CourseMutation) AddCategoryIDs(ids ...string) {
	if m.categories == nil {
		m.categories = make(map[string]struct{})
	}
	for i := range ids {
		m.categories[ids[i]] = struct{}{}
	}
}

// ClearCategories clears the "categories" edge to the Category entity.
func (m *CourseMutation) ClearCategories() {
	m.clearedcategories = true
}

// CategoriesCleared reports if the "categories" edge to the Category entity was cleared.
func (m *CourseMutation) CategoriesCleared() bool {
	return m.clearedcategories
}

// RemoveCategoryIDs removes the "categories" edge to the Category entity by IDs.
func (m *CourseMutation) RemoveCategoryIDs(ids ...string) {
	if m.removedcategories == nil {
		m.removedcategories = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.categories, ids[i])
		m.removedcategories[ids[i]] = struct{}{}
	}
}

// RemovedCategories returns the removed IDs of the "categories" edge to the Category entity.
func (m *CourseMutation) RemovedCategoriesIDs() (ids []string) {
	for id := range m.removedcategories {
		ids = append(ids, id)
	}
	return
}

// CategoriesIDs returns the "categories" edge IDs in the mutation.
func (m *CourseMutation) CategoriesIDs() (ids []string) {
	for id := range m.categories {
		ids = append(ids, id)
	}
	return
}

// ResetCategories resets all changes to the "categories" edge.
func (m *CourseMutation) ResetCategories() {
	m.categories = nil
	m.clearedcategories = false
	m.removedcategories = nil
}

// Where appends a list predicates to the CourseMutation builder.
func (m *CourseMutation) Where(ps ...predicate.Course) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CourseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CourseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Course, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CourseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.isRecommend != nil {
		fields = append(fields, course.FieldIsRecommend)
	}
	if m.isIntegral != nil {
		fields = append(fields, course.FieldIsIntegral)
	}
	if m.saleType != nil {
		fields = append(fields, course.FieldSaleType)
	}
	if m.discountPrice != nil {
		fields = append(fields, course.FieldDiscountPrice)
	}
	if m.teachingType != nil {
		fields = append(fields, course.FieldTeachingType)
	}
	if m.courseLevel != nil {
		fields = append(fields, course.FieldCourseLevel)
	}
	if m.updateBy != nil {
		fields = append(fields, course.FieldUpdateBy)
	}
	if m.lecturerName != nil {
		fields = append(fields, course.FieldLecturerName)
	}
	if m.purchaseCnt != nil {
		fields = append(fields, course.FieldPurchaseCnt)
	}
	if m.totalHour != nil {
		fields = append(fields, course.FieldTotalHour)
	}
	if m.bizCourseDetail != nil {
		fields = append(fields, course.FieldBizCourseDetail)
	}
	if m.courseCover != nil {
		fields = append(fields, course.FieldCourseCover)
	}
	if m.bizCourseChapters != nil {
		fields = append(fields, course.FieldBizCourseChapters)
	}
	if m.salePrice != nil {
		fields = append(fields, course.FieldSalePrice)
	}
	if m.bizCourseTeacher != nil {
		fields = append(fields, course.FieldBizCourseTeacher)
	}
	if m.bizCourseAttachments != nil {
		fields = append(fields, course.FieldBizCourseAttachments)
	}
	if m.updateTime != nil {
		fields = append(fields, course.FieldUpdateTime)
	}
	if m.tags != nil {
		fields = append(fields, course.FieldTags)
	}
	if m.courseName != nil {
		fields = append(fields, course.FieldCourseName)
	}
	if m.createBy != nil {
		fields = append(fields, course.FieldCreateBy)
	}
	if m.purchaseCounter != nil {
		fields = append(fields, course.FieldPurchaseCounter)
	}
	if m.createTime != nil {
		fields = append(fields, course.FieldCreateTime)
	}
	if m.clicks != nil {
		fields = append(fields, course.FieldClicks)
	}
	if m.status != nil {
		fields = append(fields, course.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldIsRecommend:
		return m.IsRecommend()
	case course.FieldIsIntegral:
		return m.IsIntegral()
	case course.FieldSaleType:
		return m.SaleType()
	case course.FieldDiscountPrice:
		return m.DiscountPrice()
	case course.FieldTeachingType:
		return m.TeachingType()
	case course.FieldCourseLevel:
		return m.CourseLevel()
	case course.FieldUpdateBy:
		return m.UpdateBy()
	case course.FieldLecturerName:
		return m.LecturerName()
	case course.FieldPurchaseCnt:
		return m.PurchaseCnt()
	case course.FieldTotalHour:
		return m.TotalHour()
	case course.FieldBizCourseDetail:
		return m.BizCourseDetail()
	case course.FieldCourseCover:
		return m.CourseCover()
	case course.FieldBizCourseChapters:
		return m.BizCourseChapters()
	case course.FieldSalePrice:
		return m.SalePrice()
	case course.FieldBizCourseTeacher:
		return m.BizCourseTeacher()
	case course.FieldBizCourseAttachments:
		return m.BizCourseAttachments()
	case course.FieldUpdateTime:
		return m.UpdateTime()
	case course.FieldTags:
		return m.Tags()
	case course.FieldCourseName:
		return m.CourseName()
	case course.FieldCreateBy:
		return m.CreateBy()
	case course.FieldPurchaseCounter:
		return m.PurchaseCounter()
	case course.FieldCreateTime:
		return m.CreateTime()
	case course.FieldClicks:
		return m.Clicks()
	case course.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldIsRecommend:
		return m.OldIsRecommend(ctx)
	case course.FieldIsIntegral:
		return m.OldIsIntegral(ctx)
	case course.FieldSaleType:
		return m.OldSaleType(ctx)
	case course.FieldDiscountPrice:
		return m.OldDiscountPrice(ctx)
	case course.FieldTeachingType:
		return m.OldTeachingType(ctx)
	case course.FieldCourseLevel:
		return m.OldCourseLevel(ctx)
	case course.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case course.FieldLecturerName:
		return m.OldLecturerName(ctx)
	case course.FieldPurchaseCnt:
		return m.OldPurchaseCnt(ctx)
	case course.FieldTotalHour:
		return m.OldTotalHour(ctx)
	case course.FieldBizCourseDetail:
		return m.OldBizCourseDetail(ctx)
	case course.FieldCourseCover:
		return m.OldCourseCover(ctx)
	case course.FieldBizCourseChapters:
		return m.OldBizCourseChapters(ctx)
	case course.FieldSalePrice:
		return m.OldSalePrice(ctx)
	case course.FieldBizCourseTeacher:
		return m.OldBizCourseTeacher(ctx)
	case course.FieldBizCourseAttachments:
		return m.OldBizCourseAttachments(ctx)
	case course.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case course.FieldTags:
		return m.OldTags(ctx)
	case course.FieldCourseName:
		return m.OldCourseName(ctx)
	case course.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case course.FieldPurchaseCounter:
		return m.OldPurchaseCounter(ctx)
	case course.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case course.FieldClicks:
		return m.OldClicks(ctx)
	case course.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldIsRecommend:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRecommend(v)
		return nil
	case course.FieldIsIntegral:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsIntegral(v)
		return nil
	case course.FieldSaleType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaleType(v)
		return nil
	case course.FieldDiscountPrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountPrice(v)
		return nil
	case course.FieldTeachingType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTeachingType(v)
		return nil
	case course.FieldCourseLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseLevel(v)
		return nil
	case course.FieldUpdateBy:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case course.FieldLecturerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLecturerName(v)
		return nil
	case course.FieldPurchaseCnt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseCnt(v)
		return nil
	case course.FieldTotalHour:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalHour(v)
		return nil
	case course.FieldBizCourseDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizCourseDetail(v)
		return nil
	case course.FieldCourseCover:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseCover(v)
		return nil
	case course.FieldBizCourseChapters:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizCourseChapters(v)
		return nil
	case course.FieldSalePrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalePrice(v)
		return nil
	case course.FieldBizCourseTeacher:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizCourseTeacher(v)
		return nil
	case course.FieldBizCourseAttachments:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBizCourseAttachments(v)
		return nil
	case course.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case course.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case course.FieldCourseName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseName(v)
		return nil
	case course.FieldCreateBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case course.FieldPurchaseCounter:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPurchaseCounter(v)
		return nil
	case course.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case course.FieldClicks:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClicks(v)
		return nil
	case course.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseMutation) AddedFields() []string {
	var fields []string
	if m.addsaleType != nil {
		fields = append(fields, course.FieldSaleType)
	}
	if m.adddiscountPrice != nil {
		fields = append(fields, course.FieldDiscountPrice)
	}
	if m.addteachingType != nil {
		fields = append(fields, course.FieldTeachingType)
	}
	if m.addcourseLevel != nil {
		fields = append(fields, course.FieldCourseLevel)
	}
	if m.addpurchaseCnt != nil {
		fields = append(fields, course.FieldPurchaseCnt)
	}
	if m.addtotalHour != nil {
		fields = append(fields, course.FieldTotalHour)
	}
	if m.addsalePrice != nil {
		fields = append(fields, course.FieldSalePrice)
	}
	if m.addpurchaseCounter != nil {
		fields = append(fields, course.FieldPurchaseCounter)
	}
	if m.addclicks != nil {
		fields = append(fields, course.FieldClicks)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case course.FieldSaleType:
		return m.AddedSaleType()
	case course.FieldDiscountPrice:
		return m.AddedDiscountPrice()
	case course.FieldTeachingType:
		return m.AddedTeachingType()
	case course.FieldCourseLevel:
		return m.AddedCourseLevel()
	case course.FieldPurchaseCnt:
		return m.AddedPurchaseCnt()
	case course.FieldTotalHour:
		return m.AddedTotalHour()
	case course.FieldSalePrice:
		return m.AddedSalePrice()
	case course.FieldPurchaseCounter:
		return m.AddedPurchaseCounter()
	case course.FieldClicks:
		return m.AddedClicks()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case course.FieldSaleType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSaleType(v)
		return nil
	case course.FieldDiscountPrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountPrice(v)
		return nil
	case course.FieldTeachingType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTeachingType(v)
		return nil
	case course.FieldCourseLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCourseLevel(v)
		return nil
	case course.FieldPurchaseCnt:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPurchaseCnt(v)
		return nil
	case course.FieldTotalHour:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalHour(v)
		return nil
	case course.FieldSalePrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalePrice(v)
		return nil
	case course.FieldPurchaseCounter:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPurchaseCounter(v)
		return nil
	case course.FieldClicks:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClicks(v)
		return nil
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldIsRecommend:
		m.ResetIsRecommend()
		return nil
	case course.FieldIsIntegral:
		m.ResetIsIntegral()
		return nil
	case course.FieldSaleType:
		m.ResetSaleType()
		return nil
	case course.FieldDiscountPrice:
		m.ResetDiscountPrice()
		return nil
	case course.FieldTeachingType:
		m.ResetTeachingType()
		return nil
	case course.FieldCourseLevel:
		m.ResetCourseLevel()
		return nil
	case course.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case course.FieldLecturerName:
		m.ResetLecturerName()
		return nil
	case course.FieldPurchaseCnt:
		m.ResetPurchaseCnt()
		return nil
	case course.FieldTotalHour:
		m.ResetTotalHour()
		return nil
	case course.FieldBizCourseDetail:
		m.ResetBizCourseDetail()
		return nil
	case course.FieldCourseCover:
		m.ResetCourseCover()
		return nil
	case course.FieldBizCourseChapters:
		m.ResetBizCourseChapters()
		return nil
	case course.FieldSalePrice:
		m.ResetSalePrice()
		return nil
	case course.FieldBizCourseTeacher:
		m.ResetBizCourseTeacher()
		return nil
	case course.FieldBizCourseAttachments:
		m.ResetBizCourseAttachments()
		return nil
	case course.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case course.FieldTags:
		m.ResetTags()
		return nil
	case course.FieldCourseName:
		m.ResetCourseName()
		return nil
	case course.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case course.FieldPurchaseCounter:
		m.ResetPurchaseCounter()
		return nil
	case course.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case course.FieldClicks:
		m.ResetClicks()
		return nil
	case course.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.categories != nil {
		edges = append(edges, course.EdgeCategories)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.categories))
		for id := range m.categories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcategories != nil {
		edges = append(edges, course.EdgeCategories)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeCategories:
		ids := make([]ent.Value, 0, len(m.removedcategories))
		for id := range m.removedcategories {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedcategories {
		edges = append(edges, course.EdgeCategories)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeCategories:
		return m.clearedcategories
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeCategories:
		m.ResetCategories()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// MemberMutation represents an operation that mutates the Member nodes in the graph.
type MemberMutation struct {
	config
	op            Op
	typ           string
	id            *string
	orderNumber   *string
	vipName       *string
	vipId         *string
	vipDesc       *string
	startTime     *time.Time
	endTime       *time.Time
	isExpired     *bool
	memberId      *string
	vipIcon       *string
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Member, error)
	predicates    []predicate.Member
}

var _ ent.Mutation = (*MemberMutation)(nil)

// memberOption allows management of the mutation configuration using functional options.
type memberOption func(*MemberMutation)

// newMemberMutation creates new mutation for the Member entity.
func newMemberMutation(c config, op Op, opts ...memberOption) *MemberMutation {
	m := &MemberMutation{
		config:        c,
		op:            op,
		typ:           TypeMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMemberID sets the ID field of the mutation.
func withMemberID(id string) memberOption {
	return func(m *MemberMutation) {
		var (
			err   error
			once  sync.Once
			value *Member
		)
		m.oldValue = func(ctx context.Context) (*Member, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Member.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMember sets the old Member of the mutation.
func withMember(node *Member) memberOption {
	return func(m *MemberMutation) {
		m.oldValue = func(context.Context) (*Member, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Member entities.
func (m *MemberMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MemberMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MemberMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Member.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderNumber sets the "orderNumber" field.
func (m *MemberMutation) SetOrderNumber(s string) {
	m.orderNumber = &s
}

// OrderNumber returns the value of the "orderNumber" field in the mutation.
func (m *MemberMutation) OrderNumber() (r string, exists bool) {
	v := m.orderNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderNumber returns the old "orderNumber" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldOrderNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderNumber: %w", err)
	}
	return oldValue.OrderNumber, nil
}

// ResetOrderNumber resets all changes to the "orderNumber" field.
func (m *MemberMutation) ResetOrderNumber() {
	m.orderNumber = nil
}

// SetVipName sets the "vipName" field.
func (m *MemberMutation) SetVipName(s string) {
	m.vipName = &s
}

// VipName returns the value of the "vipName" field in the mutation.
func (m *MemberMutation) VipName() (r string, exists bool) {
	v := m.vipName
	if v == nil {
		return
	}
	return *v, true
}

// OldVipName returns the old "vipName" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldVipName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVipName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVipName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVipName: %w", err)
	}
	return oldValue.VipName, nil
}

// ResetVipName resets all changes to the "vipName" field.
func (m *MemberMutation) ResetVipName() {
	m.vipName = nil
}

// SetVipId sets the "vipId" field.
func (m *MemberMutation) SetVipId(s string) {
	m.vipId = &s
}

// VipId returns the value of the "vipId" field in the mutation.
func (m *MemberMutation) VipId() (r string, exists bool) {
	v := m.vipId
	if v == nil {
		return
	}
	return *v, true
}

// OldVipId returns the old "vipId" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldVipId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVipId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVipId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVipId: %w", err)
	}
	return oldValue.VipId, nil
}

// ResetVipId resets all changes to the "vipId" field.
func (m *MemberMutation) ResetVipId() {
	m.vipId = nil
}

// SetVipDesc sets the "vipDesc" field.
func (m *MemberMutation) SetVipDesc(s string) {
	m.vipDesc = &s
}

// VipDesc returns the value of the "vipDesc" field in the mutation.
func (m *MemberMutation) VipDesc() (r string, exists bool) {
	v := m.vipDesc
	if v == nil {
		return
	}
	return *v, true
}

// OldVipDesc returns the old "vipDesc" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldVipDesc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVipDesc is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVipDesc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVipDesc: %w", err)
	}
	return oldValue.VipDesc, nil
}

// ResetVipDesc resets all changes to the "vipDesc" field.
func (m *MemberMutation) ResetVipDesc() {
	m.vipDesc = nil
}

// SetStartTime sets the "startTime" field.
func (m *MemberMutation) SetStartTime(t time.Time) {
	m.startTime = &t
}

// StartTime returns the value of the "startTime" field in the mutation.
func (m *MemberMutation) StartTime() (r time.Time, exists bool) {
	v := m.startTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStartTime returns the old "startTime" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldStartTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartTime: %w", err)
	}
	return oldValue.StartTime, nil
}

// ResetStartTime resets all changes to the "startTime" field.
func (m *MemberMutation) ResetStartTime() {
	m.startTime = nil
}

// SetEndTime sets the "endTime" field.
func (m *MemberMutation) SetEndTime(t time.Time) {
	m.endTime = &t
}

// EndTime returns the value of the "endTime" field in the mutation.
func (m *MemberMutation) EndTime() (r time.Time, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "endTime" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ResetEndTime resets all changes to the "endTime" field.
func (m *MemberMutation) ResetEndTime() {
	m.endTime = nil
}

// SetIsExpired sets the "isExpired" field.
func (m *MemberMutation) SetIsExpired(b bool) {
	m.isExpired = &b
}

// IsExpired returns the value of the "isExpired" field in the mutation.
func (m *MemberMutation) IsExpired() (r bool, exists bool) {
	v := m.isExpired
	if v == nil {
		return
	}
	return *v, true
}

// OldIsExpired returns the old "isExpired" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldIsExpired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsExpired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsExpired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsExpired: %w", err)
	}
	return oldValue.IsExpired, nil
}

// ResetIsExpired resets all changes to the "isExpired" field.
func (m *MemberMutation) ResetIsExpired() {
	m.isExpired = nil
}

// SetMemberId sets the "memberId" field.
func (m *MemberMutation) SetMemberId(s string) {
	m.memberId = &s
}

// MemberId returns the value of the "memberId" field in the mutation.
func (m *MemberMutation) MemberId() (r string, exists bool) {
	v := m.memberId
	if v == nil {
		return
	}
	return *v, true
}

// OldMemberId returns the old "memberId" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldMemberId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemberId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemberId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemberId: %w", err)
	}
	return oldValue.MemberId, nil
}

// ResetMemberId resets all changes to the "memberId" field.
func (m *MemberMutation) ResetMemberId() {
	m.memberId = nil
}

// SetVipIcon sets the "vipIcon" field.
func (m *MemberMutation) SetVipIcon(s string) {
	m.vipIcon = &s
}

// VipIcon returns the value of the "vipIcon" field in the mutation.
func (m *MemberMutation) VipIcon() (r string, exists bool) {
	v := m.vipIcon
	if v == nil {
		return
	}
	return *v, true
}

// OldVipIcon returns the old "vipIcon" field's value of the Member entity.
// If the Member object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MemberMutation) OldVipIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVipIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVipIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVipIcon: %w", err)
	}
	return oldValue.VipIcon, nil
}

// ResetVipIcon resets all changes to the "vipIcon" field.
func (m *MemberMutation) ResetVipIcon() {
	m.vipIcon = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *MemberMutation) SetUserID(id string) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *MemberMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *MemberMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *MemberMutation) UserID() (id string, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *MemberMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *MemberMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the MemberMutation builder.
func (m *MemberMutation) Where(ps ...predicate.Member) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MemberMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MemberMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Member, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MemberMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MemberMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Member).
func (m *MemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MemberMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.orderNumber != nil {
		fields = append(fields, member.FieldOrderNumber)
	}
	if m.vipName != nil {
		fields = append(fields, member.FieldVipName)
	}
	if m.vipId != nil {
		fields = append(fields, member.FieldVipId)
	}
	if m.vipDesc != nil {
		fields = append(fields, member.FieldVipDesc)
	}
	if m.startTime != nil {
		fields = append(fields, member.FieldStartTime)
	}
	if m.endTime != nil {
		fields = append(fields, member.FieldEndTime)
	}
	if m.isExpired != nil {
		fields = append(fields, member.FieldIsExpired)
	}
	if m.memberId != nil {
		fields = append(fields, member.FieldMemberId)
	}
	if m.vipIcon != nil {
		fields = append(fields, member.FieldVipIcon)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case member.FieldOrderNumber:
		return m.OrderNumber()
	case member.FieldVipName:
		return m.VipName()
	case member.FieldVipId:
		return m.VipId()
	case member.FieldVipDesc:
		return m.VipDesc()
	case member.FieldStartTime:
		return m.StartTime()
	case member.FieldEndTime:
		return m.EndTime()
	case member.FieldIsExpired:
		return m.IsExpired()
	case member.FieldMemberId:
		return m.MemberId()
	case member.FieldVipIcon:
		return m.VipIcon()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case member.FieldOrderNumber:
		return m.OldOrderNumber(ctx)
	case member.FieldVipName:
		return m.OldVipName(ctx)
	case member.FieldVipId:
		return m.OldVipId(ctx)
	case member.FieldVipDesc:
		return m.OldVipDesc(ctx)
	case member.FieldStartTime:
		return m.OldStartTime(ctx)
	case member.FieldEndTime:
		return m.OldEndTime(ctx)
	case member.FieldIsExpired:
		return m.OldIsExpired(ctx)
	case member.FieldMemberId:
		return m.OldMemberId(ctx)
	case member.FieldVipIcon:
		return m.OldVipIcon(ctx)
	}
	return nil, fmt.Errorf("unknown Member field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case member.FieldOrderNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderNumber(v)
		return nil
	case member.FieldVipName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVipName(v)
		return nil
	case member.FieldVipId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVipId(v)
		return nil
	case member.FieldVipDesc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVipDesc(v)
		return nil
	case member.FieldStartTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartTime(v)
		return nil
	case member.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case member.FieldIsExpired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsExpired(v)
		return nil
	case member.FieldMemberId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemberId(v)
		return nil
	case member.FieldVipIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVipIcon(v)
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MemberMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MemberMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Member numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Member nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MemberMutation) ResetField(name string) error {
	switch name {
	case member.FieldOrderNumber:
		m.ResetOrderNumber()
		return nil
	case member.FieldVipName:
		m.ResetVipName()
		return nil
	case member.FieldVipId:
		m.ResetVipId()
		return nil
	case member.FieldVipDesc:
		m.ResetVipDesc()
		return nil
	case member.FieldStartTime:
		m.ResetStartTime()
		return nil
	case member.FieldEndTime:
		m.ResetEndTime()
		return nil
	case member.FieldIsExpired:
		m.ResetIsExpired()
		return nil
	case member.FieldMemberId:
		m.ResetMemberId()
		return nil
	case member.FieldVipIcon:
		m.ResetVipIcon()
		return nil
	}
	return fmt.Errorf("unknown Member field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, member.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case member.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MemberMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, member.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MemberMutation) EdgeCleared(name string) bool {
	switch name {
	case member.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MemberMutation) ClearEdge(name string) error {
	switch name {
	case member.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Member unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MemberMutation) ResetEdge(name string) error {
	switch name {
	case member.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Member edge %s", name)
}

// SliderMutation represents an operation that mutates the Slider nodes in the graph.
type SliderMutation struct {
	config
	op            Op
	typ           string
	id            *string
	createBy      *string
	imageName     *string
	createTime    *time.Time
	updateBy      *string
	imageRemark   *string
	imageUrl      *string
	pcHref        *string
	updateTime    *time.Time
	appHref       *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Slider, error)
	predicates    []predicate.Slider
}

var _ ent.Mutation = (*SliderMutation)(nil)

// sliderOption allows management of the mutation configuration using functional options.
type sliderOption func(*SliderMutation)

// newSliderMutation creates new mutation for the Slider entity.
func newSliderMutation(c config, op Op, opts ...sliderOption) *SliderMutation {
	m := &SliderMutation{
		config:        c,
		op:            op,
		typ:           TypeSlider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSliderID sets the ID field of the mutation.
func withSliderID(id string) sliderOption {
	return func(m *SliderMutation) {
		var (
			err   error
			once  sync.Once
			value *Slider
		)
		m.oldValue = func(ctx context.Context) (*Slider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Slider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSlider sets the old Slider of the mutation.
func withSlider(node *Slider) sliderOption {
	return func(m *SliderMutation) {
		m.oldValue = func(context.Context) (*Slider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SliderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SliderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Slider entities.
func (m *SliderMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SliderMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SliderMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Slider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreateBy sets the "createBy" field.
func (m *SliderMutation) SetCreateBy(s string) {
	m.createBy = &s
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *SliderMutation) CreateBy() (r string, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldCreateBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *SliderMutation) ResetCreateBy() {
	m.createBy = nil
}

// SetImageName sets the "imageName" field.
func (m *SliderMutation) SetImageName(s string) {
	m.imageName = &s
}

// ImageName returns the value of the "imageName" field in the mutation.
func (m *SliderMutation) ImageName() (r string, exists bool) {
	v := m.imageName
	if v == nil {
		return
	}
	return *v, true
}

// OldImageName returns the old "imageName" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldImageName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageName: %w", err)
	}
	return oldValue.ImageName, nil
}

// ResetImageName resets all changes to the "imageName" field.
func (m *SliderMutation) ResetImageName() {
	m.imageName = nil
}

// SetCreateTime sets the "createTime" field.
func (m *SliderMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *SliderMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *SliderMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *SliderMutation) SetUpdateBy(s string) {
	m.updateBy = &s
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *SliderMutation) UpdateBy() (r string, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldUpdateBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *SliderMutation) ResetUpdateBy() {
	m.updateBy = nil
}

// SetImageRemark sets the "imageRemark" field.
func (m *SliderMutation) SetImageRemark(s string) {
	m.imageRemark = &s
}

// ImageRemark returns the value of the "imageRemark" field in the mutation.
func (m *SliderMutation) ImageRemark() (r string, exists bool) {
	v := m.imageRemark
	if v == nil {
		return
	}
	return *v, true
}

// OldImageRemark returns the old "imageRemark" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldImageRemark(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageRemark is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageRemark requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageRemark: %w", err)
	}
	return oldValue.ImageRemark, nil
}

// ResetImageRemark resets all changes to the "imageRemark" field.
func (m *SliderMutation) ResetImageRemark() {
	m.imageRemark = nil
}

// SetImageUrl sets the "imageUrl" field.
func (m *SliderMutation) SetImageUrl(s string) {
	m.imageUrl = &s
}

// ImageUrl returns the value of the "imageUrl" field in the mutation.
func (m *SliderMutation) ImageUrl() (r string, exists bool) {
	v := m.imageUrl
	if v == nil {
		return
	}
	return *v, true
}

// OldImageUrl returns the old "imageUrl" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldImageUrl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageUrl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageUrl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageUrl: %w", err)
	}
	return oldValue.ImageUrl, nil
}

// ResetImageUrl resets all changes to the "imageUrl" field.
func (m *SliderMutation) ResetImageUrl() {
	m.imageUrl = nil
}

// SetPcHref sets the "pcHref" field.
func (m *SliderMutation) SetPcHref(s string) {
	m.pcHref = &s
}

// PcHref returns the value of the "pcHref" field in the mutation.
func (m *SliderMutation) PcHref() (r string, exists bool) {
	v := m.pcHref
	if v == nil {
		return
	}
	return *v, true
}

// OldPcHref returns the old "pcHref" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldPcHref(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPcHref is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPcHref requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPcHref: %w", err)
	}
	return oldValue.PcHref, nil
}

// ResetPcHref resets all changes to the "pcHref" field.
func (m *SliderMutation) ResetPcHref() {
	m.pcHref = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *SliderMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *SliderMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *SliderMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// SetAppHref sets the "appHref" field.
func (m *SliderMutation) SetAppHref(s string) {
	m.appHref = &s
}

// AppHref returns the value of the "appHref" field in the mutation.
func (m *SliderMutation) AppHref() (r string, exists bool) {
	v := m.appHref
	if v == nil {
		return
	}
	return *v, true
}

// OldAppHref returns the old "appHref" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldAppHref(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppHref is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppHref requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppHref: %w", err)
	}
	return oldValue.AppHref, nil
}

// ResetAppHref resets all changes to the "appHref" field.
func (m *SliderMutation) ResetAppHref() {
	m.appHref = nil
}

// Where appends a list predicates to the SliderMutation builder.
func (m *SliderMutation) Where(ps ...predicate.Slider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SliderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SliderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Slider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SliderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SliderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Slider).
func (m *SliderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SliderMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.createBy != nil {
		fields = append(fields, slider.FieldCreateBy)
	}
	if m.imageName != nil {
		fields = append(fields, slider.FieldImageName)
	}
	if m.createTime != nil {
		fields = append(fields, slider.FieldCreateTime)
	}
	if m.updateBy != nil {
		fields = append(fields, slider.FieldUpdateBy)
	}
	if m.imageRemark != nil {
		fields = append(fields, slider.FieldImageRemark)
	}
	if m.imageUrl != nil {
		fields = append(fields, slider.FieldImageUrl)
	}
	if m.pcHref != nil {
		fields = append(fields, slider.FieldPcHref)
	}
	if m.updateTime != nil {
		fields = append(fields, slider.FieldUpdateTime)
	}
	if m.appHref != nil {
		fields = append(fields, slider.FieldAppHref)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SliderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case slider.FieldCreateBy:
		return m.CreateBy()
	case slider.FieldImageName:
		return m.ImageName()
	case slider.FieldCreateTime:
		return m.CreateTime()
	case slider.FieldUpdateBy:
		return m.UpdateBy()
	case slider.FieldImageRemark:
		return m.ImageRemark()
	case slider.FieldImageUrl:
		return m.ImageUrl()
	case slider.FieldPcHref:
		return m.PcHref()
	case slider.FieldUpdateTime:
		return m.UpdateTime()
	case slider.FieldAppHref:
		return m.AppHref()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SliderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case slider.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case slider.FieldImageName:
		return m.OldImageName(ctx)
	case slider.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case slider.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case slider.FieldImageRemark:
		return m.OldImageRemark(ctx)
	case slider.FieldImageUrl:
		return m.OldImageUrl(ctx)
	case slider.FieldPcHref:
		return m.OldPcHref(ctx)
	case slider.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case slider.FieldAppHref:
		return m.OldAppHref(ctx)
	}
	return nil, fmt.Errorf("unknown Slider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SliderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case slider.FieldCreateBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case slider.FieldImageName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageName(v)
		return nil
	case slider.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case slider.FieldUpdateBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case slider.FieldImageRemark:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageRemark(v)
		return nil
	case slider.FieldImageUrl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageUrl(v)
		return nil
	case slider.FieldPcHref:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPcHref(v)
		return nil
	case slider.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case slider.FieldAppHref:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppHref(v)
		return nil
	}
	return fmt.Errorf("unknown Slider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SliderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SliderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SliderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Slider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SliderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SliderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SliderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Slider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SliderMutation) ResetField(name string) error {
	switch name {
	case slider.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case slider.FieldImageName:
		m.ResetImageName()
		return nil
	case slider.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case slider.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case slider.FieldImageRemark:
		m.ResetImageRemark()
		return nil
	case slider.FieldImageUrl:
		m.ResetImageUrl()
		return nil
	case slider.FieldPcHref:
		m.ResetPcHref()
		return nil
	case slider.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case slider.FieldAppHref:
		m.ResetAppHref()
		return nil
	}
	return fmt.Errorf("unknown Slider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SliderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SliderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SliderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SliderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SliderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SliderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SliderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Slider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SliderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Slider edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op            Op
	typ           string
	id            *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Token, error)
	predicates    []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id int) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Token edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	gender                 *int32
	addgender              *int32
	birthday               *time.Time
	sysCode                *string
	city                   *string
	country                *string
	highestEducation       *string
	isEnable               *bool
	password               *string
	province               *string
	updateBy               *string
	createBy               *string
	platformAuthUser       *string
	email                  *string
	totalHour              *float32
	addtotalHour           *float32
	qq                     *string
	address                *string
	nickName               *string
	emergencyContact       *string
	emergencyContactNumber *string
	mobile                 *string
	wechat                 *string
	regSource              *int32
	addregSource           *int32
	telephone              *string
	updateTime             *time.Time
	avatar                 *string
	realName               *string
	createTime             *time.Time
	personalSignature      *string
	certificateNumber      *string
	age                    *int32
	addage                 *int32
	residenceAddress       *string
	username               *string
	certificateType        *string
	clearedFields          map[string]struct{}
	vipMember              map[string]struct{}
	removedvipMember       map[string]struct{}
	clearedvipMember       bool
	done                   bool
	oldValue               func(context.Context) (*User, error)
	predicates             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGender sets the "gender" field.
func (m *UserMutation) SetGender(i int32) {
	m.gender = &i
	m.addgender = nil
}

// Gender returns the value of the "gender" field in the mutation.
func (m *UserMutation) Gender() (r int32, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldGender(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// AddGender adds i to the "gender" field.
func (m *UserMutation) AddGender(i int32) {
	if m.addgender != nil {
		*m.addgender += i
	} else {
		m.addgender = &i
	}
}

// AddedGender returns the value that was added to the "gender" field in this mutation.
func (m *UserMutation) AddedGender() (r int32, exists bool) {
	v := m.addgender
	if v == nil {
		return
	}
	return *v, true
}

// ResetGender resets all changes to the "gender" field.
func (m *UserMutation) ResetGender() {
	m.gender = nil
	m.addgender = nil
}

// SetBirthday sets the "birthday" field.
func (m *UserMutation) SetBirthday(t time.Time) {
	m.birthday = &t
}

// Birthday returns the value of the "birthday" field in the mutation.
func (m *UserMutation) Birthday() (r time.Time, exists bool) {
	v := m.birthday
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthday returns the old "birthday" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldBirthday(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthday: %w", err)
	}
	return oldValue.Birthday, nil
}

// ResetBirthday resets all changes to the "birthday" field.
func (m *UserMutation) ResetBirthday() {
	m.birthday = nil
}

// SetSysCode sets the "sysCode" field.
func (m *UserMutation) SetSysCode(s string) {
	m.sysCode = &s
}

// SysCode returns the value of the "sysCode" field in the mutation.
func (m *UserMutation) SysCode() (r string, exists bool) {
	v := m.sysCode
	if v == nil {
		return
	}
	return *v, true
}

// OldSysCode returns the old "sysCode" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSysCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSysCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSysCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSysCode: %w", err)
	}
	return oldValue.SysCode, nil
}

// ResetSysCode resets all changes to the "sysCode" field.
func (m *UserMutation) ResetSysCode() {
	m.sysCode = nil
}

// SetCity sets the "city" field.
func (m *UserMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *UserMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *UserMutation) ResetCity() {
	m.city = nil
}

// SetCountry sets the "country" field.
func (m *UserMutation) SetCountry(s string) {
	m.country = &s
}

// Country returns the value of the "country" field in the mutation.
func (m *UserMutation) Country() (r string, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *UserMutation) ResetCountry() {
	m.country = nil
}

// SetHighestEducation sets the "highestEducation" field.
func (m *UserMutation) SetHighestEducation(s string) {
	m.highestEducation = &s
}

// HighestEducation returns the value of the "highestEducation" field in the mutation.
func (m *UserMutation) HighestEducation() (r string, exists bool) {
	v := m.highestEducation
	if v == nil {
		return
	}
	return *v, true
}

// OldHighestEducation returns the old "highestEducation" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHighestEducation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHighestEducation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHighestEducation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHighestEducation: %w", err)
	}
	return oldValue.HighestEducation, nil
}

// ResetHighestEducation resets all changes to the "highestEducation" field.
func (m *UserMutation) ResetHighestEducation() {
	m.highestEducation = nil
}

// SetIsEnable sets the "isEnable" field.
func (m *UserMutation) SetIsEnable(b bool) {
	m.isEnable = &b
}

// IsEnable returns the value of the "isEnable" field in the mutation.
func (m *UserMutation) IsEnable() (r bool, exists bool) {
	v := m.isEnable
	if v == nil {
		return
	}
	return *v, true
}

// OldIsEnable returns the old "isEnable" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsEnable: %w", err)
	}
	return oldValue.IsEnable, nil
}

// ResetIsEnable resets all changes to the "isEnable" field.
func (m *UserMutation) ResetIsEnable() {
	m.isEnable = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetProvince sets the "province" field.
func (m *UserMutation) SetProvince(s string) {
	m.province = &s
}

// Province returns the value of the "province" field in the mutation.
func (m *UserMutation) Province() (r string, exists bool) {
	v := m.province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "province" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldProvince(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ResetProvince resets all changes to the "province" field.
func (m *UserMutation) ResetProvince() {
	m.province = nil
}

// SetUpdateBy sets the "updateBy" field.
func (m *UserMutation) SetUpdateBy(s string) {
	m.updateBy = &s
}

// UpdateBy returns the value of the "updateBy" field in the mutation.
func (m *UserMutation) UpdateBy() (r string, exists bool) {
	v := m.updateBy
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateBy returns the old "updateBy" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateBy: %w", err)
	}
	return oldValue.UpdateBy, nil
}

// ResetUpdateBy resets all changes to the "updateBy" field.
func (m *UserMutation) ResetUpdateBy() {
	m.updateBy = nil
}

// SetCreateBy sets the "createBy" field.
func (m *UserMutation) SetCreateBy(s string) {
	m.createBy = &s
}

// CreateBy returns the value of the "createBy" field in the mutation.
func (m *UserMutation) CreateBy() (r string, exists bool) {
	v := m.createBy
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateBy returns the old "createBy" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateBy: %w", err)
	}
	return oldValue.CreateBy, nil
}

// ResetCreateBy resets all changes to the "createBy" field.
func (m *UserMutation) ResetCreateBy() {
	m.createBy = nil
}

// SetPlatformAuthUser sets the "platformAuthUser" field.
func (m *UserMutation) SetPlatformAuthUser(s string) {
	m.platformAuthUser = &s
}

// PlatformAuthUser returns the value of the "platformAuthUser" field in the mutation.
func (m *UserMutation) PlatformAuthUser() (r string, exists bool) {
	v := m.platformAuthUser
	if v == nil {
		return
	}
	return *v, true
}

// OldPlatformAuthUser returns the old "platformAuthUser" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPlatformAuthUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlatformAuthUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlatformAuthUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlatformAuthUser: %w", err)
	}
	return oldValue.PlatformAuthUser, nil
}

// ResetPlatformAuthUser resets all changes to the "platformAuthUser" field.
func (m *UserMutation) ResetPlatformAuthUser() {
	m.platformAuthUser = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetTotalHour sets the "totalHour" field.
func (m *UserMutation) SetTotalHour(f float32) {
	m.totalHour = &f
	m.addtotalHour = nil
}

// TotalHour returns the value of the "totalHour" field in the mutation.
func (m *UserMutation) TotalHour() (r float32, exists bool) {
	v := m.totalHour
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalHour returns the old "totalHour" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTotalHour(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalHour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalHour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalHour: %w", err)
	}
	return oldValue.TotalHour, nil
}

// AddTotalHour adds f to the "totalHour" field.
func (m *UserMutation) AddTotalHour(f float32) {
	if m.addtotalHour != nil {
		*m.addtotalHour += f
	} else {
		m.addtotalHour = &f
	}
}

// AddedTotalHour returns the value that was added to the "totalHour" field in this mutation.
func (m *UserMutation) AddedTotalHour() (r float32, exists bool) {
	v := m.addtotalHour
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalHour resets all changes to the "totalHour" field.
func (m *UserMutation) ResetTotalHour() {
	m.totalHour = nil
	m.addtotalHour = nil
}

// SetQq sets the "qq" field.
func (m *UserMutation) SetQq(s string) {
	m.qq = &s
}

// Qq returns the value of the "qq" field in the mutation.
func (m *UserMutation) Qq() (r string, exists bool) {
	v := m.qq
	if v == nil {
		return
	}
	return *v, true
}

// OldQq returns the old "qq" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldQq(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQq is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQq requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQq: %w", err)
	}
	return oldValue.Qq, nil
}

// ResetQq resets all changes to the "qq" field.
func (m *UserMutation) ResetQq() {
	m.qq = nil
}

// SetAddress sets the "address" field.
func (m *UserMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *UserMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ResetAddress resets all changes to the "address" field.
func (m *UserMutation) ResetAddress() {
	m.address = nil
}

// SetNickName sets the "nickName" field.
func (m *UserMutation) SetNickName(s string) {
	m.nickName = &s
}

// NickName returns the value of the "nickName" field in the mutation.
func (m *UserMutation) NickName() (r string, exists bool) {
	v := m.nickName
	if v == nil {
		return
	}
	return *v, true
}

// OldNickName returns the old "nickName" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldNickName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickName: %w", err)
	}
	return oldValue.NickName, nil
}

// ResetNickName resets all changes to the "nickName" field.
func (m *UserMutation) ResetNickName() {
	m.nickName = nil
}

// SetEmergencyContact sets the "emergencyContact" field.
func (m *UserMutation) SetEmergencyContact(s string) {
	m.emergencyContact = &s
}

// EmergencyContact returns the value of the "emergencyContact" field in the mutation.
func (m *UserMutation) EmergencyContact() (r string, exists bool) {
	v := m.emergencyContact
	if v == nil {
		return
	}
	return *v, true
}

// OldEmergencyContact returns the old "emergencyContact" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmergencyContact(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmergencyContact is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmergencyContact requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmergencyContact: %w", err)
	}
	return oldValue.EmergencyContact, nil
}

// ResetEmergencyContact resets all changes to the "emergencyContact" field.
func (m *UserMutation) ResetEmergencyContact() {
	m.emergencyContact = nil
}

// SetEmergencyContactNumber sets the "emergencyContactNumber" field.
func (m *UserMutation) SetEmergencyContactNumber(s string) {
	m.emergencyContactNumber = &s
}

// EmergencyContactNumber returns the value of the "emergencyContactNumber" field in the mutation.
func (m *UserMutation) EmergencyContactNumber() (r string, exists bool) {
	v := m.emergencyContactNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldEmergencyContactNumber returns the old "emergencyContactNumber" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmergencyContactNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmergencyContactNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmergencyContactNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmergencyContactNumber: %w", err)
	}
	return oldValue.EmergencyContactNumber, nil
}

// ResetEmergencyContactNumber resets all changes to the "emergencyContactNumber" field.
func (m *UserMutation) ResetEmergencyContactNumber() {
	m.emergencyContactNumber = nil
}

// SetMobile sets the "mobile" field.
func (m *UserMutation) SetMobile(s string) {
	m.mobile = &s
}

// Mobile returns the value of the "mobile" field in the mutation.
func (m *UserMutation) Mobile() (r string, exists bool) {
	v := m.mobile
	if v == nil {
		return
	}
	return *v, true
}

// OldMobile returns the old "mobile" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMobile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMobile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMobile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMobile: %w", err)
	}
	return oldValue.Mobile, nil
}

// ResetMobile resets all changes to the "mobile" field.
func (m *UserMutation) ResetMobile() {
	m.mobile = nil
}

// SetWechat sets the "wechat" field.
func (m *UserMutation) SetWechat(s string) {
	m.wechat = &s
}

// Wechat returns the value of the "wechat" field in the mutation.
func (m *UserMutation) Wechat() (r string, exists bool) {
	v := m.wechat
	if v == nil {
		return
	}
	return *v, true
}

// OldWechat returns the old "wechat" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWechat(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWechat is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWechat requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWechat: %w", err)
	}
	return oldValue.Wechat, nil
}

// ResetWechat resets all changes to the "wechat" field.
func (m *UserMutation) ResetWechat() {
	m.wechat = nil
}

// SetRegSource sets the "regSource" field.
func (m *UserMutation) SetRegSource(i int32) {
	m.regSource = &i
	m.addregSource = nil
}

// RegSource returns the value of the "regSource" field in the mutation.
func (m *UserMutation) RegSource() (r int32, exists bool) {
	v := m.regSource
	if v == nil {
		return
	}
	return *v, true
}

// OldRegSource returns the old "regSource" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRegSource(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegSource: %w", err)
	}
	return oldValue.RegSource, nil
}

// AddRegSource adds i to the "regSource" field.
func (m *UserMutation) AddRegSource(i int32) {
	if m.addregSource != nil {
		*m.addregSource += i
	} else {
		m.addregSource = &i
	}
}

// AddedRegSource returns the value that was added to the "regSource" field in this mutation.
func (m *UserMutation) AddedRegSource() (r int32, exists bool) {
	v := m.addregSource
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegSource resets all changes to the "regSource" field.
func (m *UserMutation) ResetRegSource() {
	m.regSource = nil
	m.addregSource = nil
}

// SetTelephone sets the "telephone" field.
func (m *UserMutation) SetTelephone(s string) {
	m.telephone = &s
}

// Telephone returns the value of the "telephone" field in the mutation.
func (m *UserMutation) Telephone() (r string, exists bool) {
	v := m.telephone
	if v == nil {
		return
	}
	return *v, true
}

// OldTelephone returns the old "telephone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTelephone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTelephone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTelephone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTelephone: %w", err)
	}
	return oldValue.Telephone, nil
}

// ResetTelephone resets all changes to the "telephone" field.
func (m *UserMutation) ResetTelephone() {
	m.telephone = nil
}

// SetUpdateTime sets the "updateTime" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.updateTime = &t
}

// UpdateTime returns the value of the "updateTime" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.updateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "updateTime" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "updateTime" field.
func (m *UserMutation) ResetUpdateTime() {
	m.updateTime = nil
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
}

// SetRealName sets the "realName" field.
func (m *UserMutation) SetRealName(s string) {
	m.realName = &s
}

// RealName returns the value of the "realName" field in the mutation.
func (m *UserMutation) RealName() (r string, exists bool) {
	v := m.realName
	if v == nil {
		return
	}
	return *v, true
}

// OldRealName returns the old "realName" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRealName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealName: %w", err)
	}
	return oldValue.RealName, nil
}

// ResetRealName resets all changes to the "realName" field.
func (m *UserMutation) ResetRealName() {
	m.realName = nil
}

// SetCreateTime sets the "createTime" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.createTime = &t
}

// CreateTime returns the value of the "createTime" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.createTime
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "createTime" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "createTime" field.
func (m *UserMutation) ResetCreateTime() {
	m.createTime = nil
}

// SetPersonalSignature sets the "personalSignature" field.
func (m *UserMutation) SetPersonalSignature(s string) {
	m.personalSignature = &s
}

// PersonalSignature returns the value of the "personalSignature" field in the mutation.
func (m *UserMutation) PersonalSignature() (r string, exists bool) {
	v := m.personalSignature
	if v == nil {
		return
	}
	return *v, true
}

// OldPersonalSignature returns the old "personalSignature" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPersonalSignature(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPersonalSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPersonalSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPersonalSignature: %w", err)
	}
	return oldValue.PersonalSignature, nil
}

// ResetPersonalSignature resets all changes to the "personalSignature" field.
func (m *UserMutation) ResetPersonalSignature() {
	m.personalSignature = nil
}

// SetCertificateNumber sets the "certificateNumber" field.
func (m *UserMutation) SetCertificateNumber(s string) {
	m.certificateNumber = &s
}

// CertificateNumber returns the value of the "certificateNumber" field in the mutation.
func (m *UserMutation) CertificateNumber() (r string, exists bool) {
	v := m.certificateNumber
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateNumber returns the old "certificateNumber" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCertificateNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateNumber: %w", err)
	}
	return oldValue.CertificateNumber, nil
}

// ResetCertificateNumber resets all changes to the "certificateNumber" field.
func (m *UserMutation) ResetCertificateNumber() {
	m.certificateNumber = nil
}

// SetAge sets the "age" field.
func (m *UserMutation) SetAge(i int32) {
	m.age = &i
	m.addage = nil
}

// Age returns the value of the "age" field in the mutation.
func (m *UserMutation) Age() (r int32, exists bool) {
	v := m.age
	if v == nil {
		return
	}
	return *v, true
}

// OldAge returns the old "age" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAge(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAge: %w", err)
	}
	return oldValue.Age, nil
}

// AddAge adds i to the "age" field.
func (m *UserMutation) AddAge(i int32) {
	if m.addage != nil {
		*m.addage += i
	} else {
		m.addage = &i
	}
}

// AddedAge returns the value that was added to the "age" field in this mutation.
func (m *UserMutation) AddedAge() (r int32, exists bool) {
	v := m.addage
	if v == nil {
		return
	}
	return *v, true
}

// ResetAge resets all changes to the "age" field.
func (m *UserMutation) ResetAge() {
	m.age = nil
	m.addage = nil
}

// SetResidenceAddress sets the "residenceAddress" field.
func (m *UserMutation) SetResidenceAddress(s string) {
	m.residenceAddress = &s
}

// ResidenceAddress returns the value of the "residenceAddress" field in the mutation.
func (m *UserMutation) ResidenceAddress() (r string, exists bool) {
	v := m.residenceAddress
	if v == nil {
		return
	}
	return *v, true
}

// OldResidenceAddress returns the old "residenceAddress" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldResidenceAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResidenceAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResidenceAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResidenceAddress: %w", err)
	}
	return oldValue.ResidenceAddress, nil
}

// ResetResidenceAddress resets all changes to the "residenceAddress" field.
func (m *UserMutation) ResetResidenceAddress() {
	m.residenceAddress = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetCertificateType sets the "certificateType" field.
func (m *UserMutation) SetCertificateType(s string) {
	m.certificateType = &s
}

// CertificateType returns the value of the "certificateType" field in the mutation.
func (m *UserMutation) CertificateType() (r string, exists bool) {
	v := m.certificateType
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateType returns the old "certificateType" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCertificateType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCertificateType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCertificateType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateType: %w", err)
	}
	return oldValue.CertificateType, nil
}

// ResetCertificateType resets all changes to the "certificateType" field.
func (m *UserMutation) ResetCertificateType() {
	m.certificateType = nil
}

// AddVipMemberIDs adds the "vipMember" edge to the Member entity by ids.
func (m *UserMutation) AddVipMemberIDs(ids ...string) {
	if m.vipMember == nil {
		m.vipMember = make(map[string]struct{})
	}
	for i := range ids {
		m.vipMember[ids[i]] = struct{}{}
	}
}

// ClearVipMember clears the "vipMember" edge to the Member entity.
func (m *UserMutation) ClearVipMember() {
	m.clearedvipMember = true
}

// VipMemberCleared reports if the "vipMember" edge to the Member entity was cleared.
func (m *UserMutation) VipMemberCleared() bool {
	return m.clearedvipMember
}

// RemoveVipMemberIDs removes the "vipMember" edge to the Member entity by IDs.
func (m *UserMutation) RemoveVipMemberIDs(ids ...string) {
	if m.removedvipMember == nil {
		m.removedvipMember = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.vipMember, ids[i])
		m.removedvipMember[ids[i]] = struct{}{}
	}
}

// RemovedVipMember returns the removed IDs of the "vipMember" edge to the Member entity.
func (m *UserMutation) RemovedVipMemberIDs() (ids []string) {
	for id := range m.removedvipMember {
		ids = append(ids, id)
	}
	return
}

// VipMemberIDs returns the "vipMember" edge IDs in the mutation.
func (m *UserMutation) VipMemberIDs() (ids []string) {
	for id := range m.vipMember {
		ids = append(ids, id)
	}
	return
}

// ResetVipMember resets all changes to the "vipMember" edge.
func (m *UserMutation) ResetVipMember() {
	m.vipMember = nil
	m.clearedvipMember = false
	m.removedvipMember = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 33)
	if m.gender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.birthday != nil {
		fields = append(fields, user.FieldBirthday)
	}
	if m.sysCode != nil {
		fields = append(fields, user.FieldSysCode)
	}
	if m.city != nil {
		fields = append(fields, user.FieldCity)
	}
	if m.country != nil {
		fields = append(fields, user.FieldCountry)
	}
	if m.highestEducation != nil {
		fields = append(fields, user.FieldHighestEducation)
	}
	if m.isEnable != nil {
		fields = append(fields, user.FieldIsEnable)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.province != nil {
		fields = append(fields, user.FieldProvince)
	}
	if m.updateBy != nil {
		fields = append(fields, user.FieldUpdateBy)
	}
	if m.createBy != nil {
		fields = append(fields, user.FieldCreateBy)
	}
	if m.platformAuthUser != nil {
		fields = append(fields, user.FieldPlatformAuthUser)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.totalHour != nil {
		fields = append(fields, user.FieldTotalHour)
	}
	if m.qq != nil {
		fields = append(fields, user.FieldQq)
	}
	if m.address != nil {
		fields = append(fields, user.FieldAddress)
	}
	if m.nickName != nil {
		fields = append(fields, user.FieldNickName)
	}
	if m.emergencyContact != nil {
		fields = append(fields, user.FieldEmergencyContact)
	}
	if m.emergencyContactNumber != nil {
		fields = append(fields, user.FieldEmergencyContactNumber)
	}
	if m.mobile != nil {
		fields = append(fields, user.FieldMobile)
	}
	if m.wechat != nil {
		fields = append(fields, user.FieldWechat)
	}
	if m.regSource != nil {
		fields = append(fields, user.FieldRegSource)
	}
	if m.telephone != nil {
		fields = append(fields, user.FieldTelephone)
	}
	if m.updateTime != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.realName != nil {
		fields = append(fields, user.FieldRealName)
	}
	if m.createTime != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.personalSignature != nil {
		fields = append(fields, user.FieldPersonalSignature)
	}
	if m.certificateNumber != nil {
		fields = append(fields, user.FieldCertificateNumber)
	}
	if m.age != nil {
		fields = append(fields, user.FieldAge)
	}
	if m.residenceAddress != nil {
		fields = append(fields, user.FieldResidenceAddress)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.certificateType != nil {
		fields = append(fields, user.FieldCertificateType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldGender:
		return m.Gender()
	case user.FieldBirthday:
		return m.Birthday()
	case user.FieldSysCode:
		return m.SysCode()
	case user.FieldCity:
		return m.City()
	case user.FieldCountry:
		return m.Country()
	case user.FieldHighestEducation:
		return m.HighestEducation()
	case user.FieldIsEnable:
		return m.IsEnable()
	case user.FieldPassword:
		return m.Password()
	case user.FieldProvince:
		return m.Province()
	case user.FieldUpdateBy:
		return m.UpdateBy()
	case user.FieldCreateBy:
		return m.CreateBy()
	case user.FieldPlatformAuthUser:
		return m.PlatformAuthUser()
	case user.FieldEmail:
		return m.Email()
	case user.FieldTotalHour:
		return m.TotalHour()
	case user.FieldQq:
		return m.Qq()
	case user.FieldAddress:
		return m.Address()
	case user.FieldNickName:
		return m.NickName()
	case user.FieldEmergencyContact:
		return m.EmergencyContact()
	case user.FieldEmergencyContactNumber:
		return m.EmergencyContactNumber()
	case user.FieldMobile:
		return m.Mobile()
	case user.FieldWechat:
		return m.Wechat()
	case user.FieldRegSource:
		return m.RegSource()
	case user.FieldTelephone:
		return m.Telephone()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldRealName:
		return m.RealName()
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldPersonalSignature:
		return m.PersonalSignature()
	case user.FieldCertificateNumber:
		return m.CertificateNumber()
	case user.FieldAge:
		return m.Age()
	case user.FieldResidenceAddress:
		return m.ResidenceAddress()
	case user.FieldUsername:
		return m.Username()
	case user.FieldCertificateType:
		return m.CertificateType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldGender:
		return m.OldGender(ctx)
	case user.FieldBirthday:
		return m.OldBirthday(ctx)
	case user.FieldSysCode:
		return m.OldSysCode(ctx)
	case user.FieldCity:
		return m.OldCity(ctx)
	case user.FieldCountry:
		return m.OldCountry(ctx)
	case user.FieldHighestEducation:
		return m.OldHighestEducation(ctx)
	case user.FieldIsEnable:
		return m.OldIsEnable(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldProvince:
		return m.OldProvince(ctx)
	case user.FieldUpdateBy:
		return m.OldUpdateBy(ctx)
	case user.FieldCreateBy:
		return m.OldCreateBy(ctx)
	case user.FieldPlatformAuthUser:
		return m.OldPlatformAuthUser(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldTotalHour:
		return m.OldTotalHour(ctx)
	case user.FieldQq:
		return m.OldQq(ctx)
	case user.FieldAddress:
		return m.OldAddress(ctx)
	case user.FieldNickName:
		return m.OldNickName(ctx)
	case user.FieldEmergencyContact:
		return m.OldEmergencyContact(ctx)
	case user.FieldEmergencyContactNumber:
		return m.OldEmergencyContactNumber(ctx)
	case user.FieldMobile:
		return m.OldMobile(ctx)
	case user.FieldWechat:
		return m.OldWechat(ctx)
	case user.FieldRegSource:
		return m.OldRegSource(ctx)
	case user.FieldTelephone:
		return m.OldTelephone(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldRealName:
		return m.OldRealName(ctx)
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldPersonalSignature:
		return m.OldPersonalSignature(ctx)
	case user.FieldCertificateNumber:
		return m.OldCertificateNumber(ctx)
	case user.FieldAge:
		return m.OldAge(ctx)
	case user.FieldResidenceAddress:
		return m.OldResidenceAddress(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldCertificateType:
		return m.OldCertificateType(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldGender:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case user.FieldBirthday:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthday(v)
		return nil
	case user.FieldSysCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSysCode(v)
		return nil
	case user.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case user.FieldCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case user.FieldHighestEducation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHighestEducation(v)
		return nil
	case user.FieldIsEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsEnable(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case user.FieldUpdateBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateBy(v)
		return nil
	case user.FieldCreateBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateBy(v)
		return nil
	case user.FieldPlatformAuthUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlatformAuthUser(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldTotalHour:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalHour(v)
		return nil
	case user.FieldQq:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQq(v)
		return nil
	case user.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case user.FieldNickName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickName(v)
		return nil
	case user.FieldEmergencyContact:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmergencyContact(v)
		return nil
	case user.FieldEmergencyContactNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmergencyContactNumber(v)
		return nil
	case user.FieldMobile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMobile(v)
		return nil
	case user.FieldWechat:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWechat(v)
		return nil
	case user.FieldRegSource:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegSource(v)
		return nil
	case user.FieldTelephone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTelephone(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldRealName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealName(v)
		return nil
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldPersonalSignature:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPersonalSignature(v)
		return nil
	case user.FieldCertificateNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateNumber(v)
		return nil
	case user.FieldAge:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAge(v)
		return nil
	case user.FieldResidenceAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResidenceAddress(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldCertificateType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateType(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addgender != nil {
		fields = append(fields, user.FieldGender)
	}
	if m.addtotalHour != nil {
		fields = append(fields, user.FieldTotalHour)
	}
	if m.addregSource != nil {
		fields = append(fields, user.FieldRegSource)
	}
	if m.addage != nil {
		fields = append(fields, user.FieldAge)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldGender:
		return m.AddedGender()
	case user.FieldTotalHour:
		return m.AddedTotalHour()
	case user.FieldRegSource:
		return m.AddedRegSource()
	case user.FieldAge:
		return m.AddedAge()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldGender:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGender(v)
		return nil
	case user.FieldTotalHour:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalHour(v)
		return nil
	case user.FieldRegSource:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegSource(v)
		return nil
	case user.FieldAge:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAge(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldGender:
		m.ResetGender()
		return nil
	case user.FieldBirthday:
		m.ResetBirthday()
		return nil
	case user.FieldSysCode:
		m.ResetSysCode()
		return nil
	case user.FieldCity:
		m.ResetCity()
		return nil
	case user.FieldCountry:
		m.ResetCountry()
		return nil
	case user.FieldHighestEducation:
		m.ResetHighestEducation()
		return nil
	case user.FieldIsEnable:
		m.ResetIsEnable()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldProvince:
		m.ResetProvince()
		return nil
	case user.FieldUpdateBy:
		m.ResetUpdateBy()
		return nil
	case user.FieldCreateBy:
		m.ResetCreateBy()
		return nil
	case user.FieldPlatformAuthUser:
		m.ResetPlatformAuthUser()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldTotalHour:
		m.ResetTotalHour()
		return nil
	case user.FieldQq:
		m.ResetQq()
		return nil
	case user.FieldAddress:
		m.ResetAddress()
		return nil
	case user.FieldNickName:
		m.ResetNickName()
		return nil
	case user.FieldEmergencyContact:
		m.ResetEmergencyContact()
		return nil
	case user.FieldEmergencyContactNumber:
		m.ResetEmergencyContactNumber()
		return nil
	case user.FieldMobile:
		m.ResetMobile()
		return nil
	case user.FieldWechat:
		m.ResetWechat()
		return nil
	case user.FieldRegSource:
		m.ResetRegSource()
		return nil
	case user.FieldTelephone:
		m.ResetTelephone()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldRealName:
		m.ResetRealName()
		return nil
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldPersonalSignature:
		m.ResetPersonalSignature()
		return nil
	case user.FieldCertificateNumber:
		m.ResetCertificateNumber()
		return nil
	case user.FieldAge:
		m.ResetAge()
		return nil
	case user.FieldResidenceAddress:
		m.ResetResidenceAddress()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldCertificateType:
		m.ResetCertificateType()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.vipMember != nil {
		edges = append(edges, user.EdgeVipMember)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeVipMember:
		ids := make([]ent.Value, 0, len(m.vipMember))
		for id := range m.vipMember {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvipMember != nil {
		edges = append(edges, user.EdgeVipMember)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeVipMember:
		ids := make([]ent.Value, 0, len(m.removedvipMember))
		for id := range m.removedvipMember {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvipMember {
		edges = append(edges, user.EdgeVipMember)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeVipMember:
		return m.clearedvipMember
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeVipMember:
		m.ResetVipMember()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
