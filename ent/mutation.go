// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"kubecit-service/ent/account"
	"kubecit-service/ent/category"
	"kubecit-service/ent/chapter"
	"kubecit-service/ent/course"
	"kubecit-service/ent/lesson"
	"kubecit-service/ent/orderinfos"
	"kubecit-service/ent/orders"
	"kubecit-service/ent/predicate"
	"kubecit-service/ent/setting"
	"kubecit-service/ent/slider"
	"kubecit-service/ent/teacher"
	"kubecit-service/ent/user"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount    = "Account"
	TypeCategory   = "Category"
	TypeChapter    = "Chapter"
	TypeCourse     = "Course"
	TypeLesson     = "Lesson"
	TypeOrderInfos = "OrderInfos"
	TypeOrders     = "Orders"
	TypeSetting    = "Setting"
	TypeSlider     = "Slider"
	TypeTeacher    = "Teacher"
	TypeUser       = "User"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op            Op
	typ           string
	id            *int
	user_id       *uint64
	adduser_id    *int64
	openid        *string
	password      *string
	method        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Account, error)
	predicates    []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *AccountMutation) SetUserID(u uint64) {
	m.user_id = &u
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AccountMutation) UserID() (r uint64, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUserID(ctx context.Context) (v uint64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds u to the "user_id" field.
func (m *AccountMutation) AddUserID(u int64) {
	if m.adduser_id != nil {
		*m.adduser_id += u
	} else {
		m.adduser_id = &u
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *AccountMutation) AddedUserID() (r int64, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AccountMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetOpenid sets the "openid" field.
func (m *AccountMutation) SetOpenid(s string) {
	m.openid = &s
}

// Openid returns the value of the "openid" field in the mutation.
func (m *AccountMutation) Openid() (r string, exists bool) {
	v := m.openid
	if v == nil {
		return
	}
	return *v, true
}

// OldOpenid returns the old "openid" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldOpenid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpenid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpenid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpenid: %w", err)
	}
	return oldValue.Openid, nil
}

// ResetOpenid resets all changes to the "openid" field.
func (m *AccountMutation) ResetOpenid() {
	m.openid = nil
}

// SetPassword sets the "password" field.
func (m *AccountMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AccountMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *AccountMutation) ResetPassword() {
	m.password = nil
}

// SetMethod sets the "method" field.
func (m *AccountMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *AccountMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *AccountMutation) ResetMethod() {
	m.method = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.user_id != nil {
		fields = append(fields, account.FieldUserID)
	}
	if m.openid != nil {
		fields = append(fields, account.FieldOpenid)
	}
	if m.password != nil {
		fields = append(fields, account.FieldPassword)
	}
	if m.method != nil {
		fields = append(fields, account.FieldMethod)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldUserID:
		return m.UserID()
	case account.FieldOpenid:
		return m.Openid()
	case account.FieldPassword:
		return m.Password()
	case account.FieldMethod:
		return m.Method()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldUserID:
		return m.OldUserID(ctx)
	case account.FieldOpenid:
		return m.OldOpenid(ctx)
	case account.FieldPassword:
		return m.OldPassword(ctx)
	case account.FieldMethod:
		return m.OldMethod(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldUserID:
		v, ok := value.(uint64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case account.FieldOpenid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpenid(v)
		return nil
	case account.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case account.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, account.FieldUserID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldUserID:
		return m.AddedUserID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldUserID:
		m.ResetUserID()
		return nil
	case account.FieldOpenid:
		m.ResetOpenid()
		return nil
	case account.FieldPassword:
		m.ResetPassword()
		return nil
	case account.FieldMethod:
		m.ResetMethod()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Account edge %s", name)
}

// CategoryMutation represents an operation that mutates the Category nodes in the graph.
type CategoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	level           *int
	addlevel        *int
	clearedFields   map[string]struct{}
	courses         map[int]struct{}
	removedcourses  map[int]struct{}
	clearedcourses  bool
	parent          *int
	clearedparent   bool
	children        map[int]struct{}
	removedchildren map[int]struct{}
	clearedchildren bool
	done            bool
	oldValue        func(context.Context) (*Category, error)
	predicates      []predicate.Category
}

var _ ent.Mutation = (*CategoryMutation)(nil)

// categoryOption allows management of the mutation configuration using functional options.
type categoryOption func(*CategoryMutation)

// newCategoryMutation creates new mutation for the Category entity.
func newCategoryMutation(c config, op Op, opts ...categoryOption) *CategoryMutation {
	m := &CategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCategoryID sets the ID field of the mutation.
func withCategoryID(id int) categoryOption {
	return func(m *CategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Category
		)
		m.oldValue = func(ctx context.Context) (*Category, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Category.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCategory sets the old Category of the mutation.
func withCategory(node *Category) categoryOption {
	return func(m *CategoryMutation) {
		m.oldValue = func(context.Context) (*Category, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Category.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CategoryMutation) ResetName() {
	m.name = nil
}

// SetLevel sets the "level" field.
func (m *CategoryMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *CategoryMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *CategoryMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *CategoryMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *CategoryMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetParentID sets the "parent_id" field.
func (m *CategoryMutation) SetParentID(i int) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *CategoryMutation) ParentID() (r int, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the Category entity.
// If the Category object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CategoryMutation) OldParentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *CategoryMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[category.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *CategoryMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[category.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *CategoryMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, category.FieldParentID)
}

// AddCourseIDs adds the "courses" edge to the Course entity by ids.
func (m *CategoryMutation) AddCourseIDs(ids ...int) {
	if m.courses == nil {
		m.courses = make(map[int]struct{})
	}
	for i := range ids {
		m.courses[ids[i]] = struct{}{}
	}
}

// ClearCourses clears the "courses" edge to the Course entity.
func (m *CategoryMutation) ClearCourses() {
	m.clearedcourses = true
}

// CoursesCleared reports if the "courses" edge to the Course entity was cleared.
func (m *CategoryMutation) CoursesCleared() bool {
	return m.clearedcourses
}

// RemoveCourseIDs removes the "courses" edge to the Course entity by IDs.
func (m *CategoryMutation) RemoveCourseIDs(ids ...int) {
	if m.removedcourses == nil {
		m.removedcourses = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.courses, ids[i])
		m.removedcourses[ids[i]] = struct{}{}
	}
}

// RemovedCourses returns the removed IDs of the "courses" edge to the Course entity.
func (m *CategoryMutation) RemovedCoursesIDs() (ids []int) {
	for id := range m.removedcourses {
		ids = append(ids, id)
	}
	return
}

// CoursesIDs returns the "courses" edge IDs in the mutation.
func (m *CategoryMutation) CoursesIDs() (ids []int) {
	for id := range m.courses {
		ids = append(ids, id)
	}
	return
}

// ResetCourses resets all changes to the "courses" edge.
func (m *CategoryMutation) ResetCourses() {
	m.courses = nil
	m.clearedcourses = false
	m.removedcourses = nil
}

// ClearParent clears the "parent" edge to the Category entity.
func (m *CategoryMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Category entity was cleared.
func (m *CategoryMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CategoryMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the Category entity by ids.
func (m *CategoryMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Category entity.
func (m *CategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Category entity was cleared.
func (m *CategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Category entity by IDs.
func (m *CategoryMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Category entity.
func (m *CategoryMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *CategoryMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *CategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the CategoryMutation builder.
func (m *CategoryMutation) Where(ps ...predicate.Category) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Category, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Category).
func (m *CategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CategoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, category.FieldName)
	}
	if m.level != nil {
		fields = append(fields, category.FieldLevel)
	}
	if m.parent != nil {
		fields = append(fields, category.FieldParentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case category.FieldName:
		return m.Name()
	case category.FieldLevel:
		return m.Level()
	case category.FieldParentID:
		return m.ParentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case category.FieldName:
		return m.OldName(ctx)
	case category.FieldLevel:
		return m.OldLevel(ctx)
	case category.FieldParentID:
		return m.OldParentID(ctx)
	}
	return nil, fmt.Errorf("unknown Category field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case category.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case category.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case category.FieldParentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CategoryMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, category.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CategoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case category.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case category.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Category numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(category.FieldParentID) {
		fields = append(fields, category.FieldParentID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CategoryMutation) ClearField(name string) error {
	switch name {
	case category.FieldParentID:
		m.ClearParentID()
		return nil
	}
	return fmt.Errorf("unknown Category nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CategoryMutation) ResetField(name string) error {
	switch name {
	case category.FieldName:
		m.ResetName()
		return nil
	case category.FieldLevel:
		m.ResetLevel()
		return nil
	case category.FieldParentID:
		m.ResetParentID()
		return nil
	}
	return fmt.Errorf("unknown Category field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.courses != nil {
		edges = append(edges, category.EdgeCourses)
	}
	if m.parent != nil {
		edges = append(edges, category.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.courses))
		for id := range m.courses {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcourses != nil {
		edges = append(edges, category.EdgeCourses)
	}
	if m.removedchildren != nil {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case category.EdgeCourses:
		ids := make([]ent.Value, 0, len(m.removedcourses))
		for id := range m.removedcourses {
			ids = append(ids, id)
		}
		return ids
	case category.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcourses {
		edges = append(edges, category.EdgeCourses)
	}
	if m.clearedparent {
		edges = append(edges, category.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, category.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case category.EdgeCourses:
		return m.clearedcourses
	case category.EdgeParent:
		return m.clearedparent
	case category.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CategoryMutation) ClearEdge(name string) error {
	switch name {
	case category.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Category unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CategoryMutation) ResetEdge(name string) error {
	switch name {
	case category.EdgeCourses:
		m.ResetCourses()
		return nil
	case category.EdgeParent:
		m.ResetParent()
		return nil
	case category.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown Category edge %s", name)
}

// ChapterMutation represents an operation that mutates the Chapter nodes in the graph.
type ChapterMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	released_time       *time.Time
	description         *string
	sort                *int
	addsort             *int
	has_free_preview    *int
	addhas_free_preview *int
	clearedFields       map[string]struct{}
	lessons             map[int]struct{}
	removedlessons      map[int]struct{}
	clearedlessons      bool
	course              *int
	clearedcourse       bool
	done                bool
	oldValue            func(context.Context) (*Chapter, error)
	predicates          []predicate.Chapter
}

var _ ent.Mutation = (*ChapterMutation)(nil)

// chapterOption allows management of the mutation configuration using functional options.
type chapterOption func(*ChapterMutation)

// newChapterMutation creates new mutation for the Chapter entity.
func newChapterMutation(c config, op Op, opts ...chapterOption) *ChapterMutation {
	m := &ChapterMutation{
		config:        c,
		op:            op,
		typ:           TypeChapter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChapterID sets the ID field of the mutation.
func withChapterID(id int) chapterOption {
	return func(m *ChapterMutation) {
		var (
			err   error
			once  sync.Once
			value *Chapter
		)
		m.oldValue = func(ctx context.Context) (*Chapter, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Chapter.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChapter sets the old Chapter of the mutation.
func withChapter(node *Chapter) chapterOption {
	return func(m *ChapterMutation) {
		m.oldValue = func(context.Context) (*Chapter, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChapterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChapterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChapterMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChapterMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Chapter.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ChapterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ChapterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ChapterMutation) ResetName() {
	m.name = nil
}

// SetReleasedTime sets the "released_time" field.
func (m *ChapterMutation) SetReleasedTime(t time.Time) {
	m.released_time = &t
}

// ReleasedTime returns the value of the "released_time" field in the mutation.
func (m *ChapterMutation) ReleasedTime() (r time.Time, exists bool) {
	v := m.released_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReleasedTime returns the old "released_time" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldReleasedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleasedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleasedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleasedTime: %w", err)
	}
	return oldValue.ReleasedTime, nil
}

// ResetReleasedTime resets all changes to the "released_time" field.
func (m *ChapterMutation) ResetReleasedTime() {
	m.released_time = nil
}

// SetDescription sets the "description" field.
func (m *ChapterMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ChapterMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ChapterMutation) ResetDescription() {
	m.description = nil
}

// SetSort sets the "sort" field.
func (m *ChapterMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *ChapterMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *ChapterMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *ChapterMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *ChapterMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetHasFreePreview sets the "has_free_preview" field.
func (m *ChapterMutation) SetHasFreePreview(i int) {
	m.has_free_preview = &i
	m.addhas_free_preview = nil
}

// HasFreePreview returns the value of the "has_free_preview" field in the mutation.
func (m *ChapterMutation) HasFreePreview() (r int, exists bool) {
	v := m.has_free_preview
	if v == nil {
		return
	}
	return *v, true
}

// OldHasFreePreview returns the old "has_free_preview" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldHasFreePreview(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHasFreePreview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHasFreePreview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHasFreePreview: %w", err)
	}
	return oldValue.HasFreePreview, nil
}

// AddHasFreePreview adds i to the "has_free_preview" field.
func (m *ChapterMutation) AddHasFreePreview(i int) {
	if m.addhas_free_preview != nil {
		*m.addhas_free_preview += i
	} else {
		m.addhas_free_preview = &i
	}
}

// AddedHasFreePreview returns the value that was added to the "has_free_preview" field in this mutation.
func (m *ChapterMutation) AddedHasFreePreview() (r int, exists bool) {
	v := m.addhas_free_preview
	if v == nil {
		return
	}
	return *v, true
}

// ResetHasFreePreview resets all changes to the "has_free_preview" field.
func (m *ChapterMutation) ResetHasFreePreview() {
	m.has_free_preview = nil
	m.addhas_free_preview = nil
}

// SetCourseID sets the "course_id" field.
func (m *ChapterMutation) SetCourseID(i int) {
	m.course = &i
}

// CourseID returns the value of the "course_id" field in the mutation.
func (m *ChapterMutation) CourseID() (r int, exists bool) {
	v := m.course
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseID returns the old "course_id" field's value of the Chapter entity.
// If the Chapter object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChapterMutation) OldCourseID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseID: %w", err)
	}
	return oldValue.CourseID, nil
}

// ClearCourseID clears the value of the "course_id" field.
func (m *ChapterMutation) ClearCourseID() {
	m.course = nil
	m.clearedFields[chapter.FieldCourseID] = struct{}{}
}

// CourseIDCleared returns if the "course_id" field was cleared in this mutation.
func (m *ChapterMutation) CourseIDCleared() bool {
	_, ok := m.clearedFields[chapter.FieldCourseID]
	return ok
}

// ResetCourseID resets all changes to the "course_id" field.
func (m *ChapterMutation) ResetCourseID() {
	m.course = nil
	delete(m.clearedFields, chapter.FieldCourseID)
}

// AddLessonIDs adds the "lessons" edge to the Lesson entity by ids.
func (m *ChapterMutation) AddLessonIDs(ids ...int) {
	if m.lessons == nil {
		m.lessons = make(map[int]struct{})
	}
	for i := range ids {
		m.lessons[ids[i]] = struct{}{}
	}
}

// ClearLessons clears the "lessons" edge to the Lesson entity.
func (m *ChapterMutation) ClearLessons() {
	m.clearedlessons = true
}

// LessonsCleared reports if the "lessons" edge to the Lesson entity was cleared.
func (m *ChapterMutation) LessonsCleared() bool {
	return m.clearedlessons
}

// RemoveLessonIDs removes the "lessons" edge to the Lesson entity by IDs.
func (m *ChapterMutation) RemoveLessonIDs(ids ...int) {
	if m.removedlessons == nil {
		m.removedlessons = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.lessons, ids[i])
		m.removedlessons[ids[i]] = struct{}{}
	}
}

// RemovedLessons returns the removed IDs of the "lessons" edge to the Lesson entity.
func (m *ChapterMutation) RemovedLessonsIDs() (ids []int) {
	for id := range m.removedlessons {
		ids = append(ids, id)
	}
	return
}

// LessonsIDs returns the "lessons" edge IDs in the mutation.
func (m *ChapterMutation) LessonsIDs() (ids []int) {
	for id := range m.lessons {
		ids = append(ids, id)
	}
	return
}

// ResetLessons resets all changes to the "lessons" edge.
func (m *ChapterMutation) ResetLessons() {
	m.lessons = nil
	m.clearedlessons = false
	m.removedlessons = nil
}

// ClearCourse clears the "course" edge to the Course entity.
func (m *ChapterMutation) ClearCourse() {
	m.clearedcourse = true
}

// CourseCleared reports if the "course" edge to the Course entity was cleared.
func (m *ChapterMutation) CourseCleared() bool {
	return m.CourseIDCleared() || m.clearedcourse
}

// CourseIDs returns the "course" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CourseID instead. It exists only for internal usage by the builders.
func (m *ChapterMutation) CourseIDs() (ids []int) {
	if id := m.course; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCourse resets all changes to the "course" edge.
func (m *ChapterMutation) ResetCourse() {
	m.course = nil
	m.clearedcourse = false
}

// Where appends a list predicates to the ChapterMutation builder.
func (m *ChapterMutation) Where(ps ...predicate.Chapter) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChapterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChapterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Chapter, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChapterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChapterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Chapter).
func (m *ChapterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChapterMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, chapter.FieldName)
	}
	if m.released_time != nil {
		fields = append(fields, chapter.FieldReleasedTime)
	}
	if m.description != nil {
		fields = append(fields, chapter.FieldDescription)
	}
	if m.sort != nil {
		fields = append(fields, chapter.FieldSort)
	}
	if m.has_free_preview != nil {
		fields = append(fields, chapter.FieldHasFreePreview)
	}
	if m.course != nil {
		fields = append(fields, chapter.FieldCourseID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChapterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case chapter.FieldName:
		return m.Name()
	case chapter.FieldReleasedTime:
		return m.ReleasedTime()
	case chapter.FieldDescription:
		return m.Description()
	case chapter.FieldSort:
		return m.Sort()
	case chapter.FieldHasFreePreview:
		return m.HasFreePreview()
	case chapter.FieldCourseID:
		return m.CourseID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChapterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case chapter.FieldName:
		return m.OldName(ctx)
	case chapter.FieldReleasedTime:
		return m.OldReleasedTime(ctx)
	case chapter.FieldDescription:
		return m.OldDescription(ctx)
	case chapter.FieldSort:
		return m.OldSort(ctx)
	case chapter.FieldHasFreePreview:
		return m.OldHasFreePreview(ctx)
	case chapter.FieldCourseID:
		return m.OldCourseID(ctx)
	}
	return nil, fmt.Errorf("unknown Chapter field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChapterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case chapter.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case chapter.FieldReleasedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleasedTime(v)
		return nil
	case chapter.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case chapter.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case chapter.FieldHasFreePreview:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHasFreePreview(v)
		return nil
	case chapter.FieldCourseID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseID(v)
		return nil
	}
	return fmt.Errorf("unknown Chapter field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChapterMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, chapter.FieldSort)
	}
	if m.addhas_free_preview != nil {
		fields = append(fields, chapter.FieldHasFreePreview)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChapterMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case chapter.FieldSort:
		return m.AddedSort()
	case chapter.FieldHasFreePreview:
		return m.AddedHasFreePreview()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChapterMutation) AddField(name string, value ent.Value) error {
	switch name {
	case chapter.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case chapter.FieldHasFreePreview:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHasFreePreview(v)
		return nil
	}
	return fmt.Errorf("unknown Chapter numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChapterMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(chapter.FieldCourseID) {
		fields = append(fields, chapter.FieldCourseID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChapterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChapterMutation) ClearField(name string) error {
	switch name {
	case chapter.FieldCourseID:
		m.ClearCourseID()
		return nil
	}
	return fmt.Errorf("unknown Chapter nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChapterMutation) ResetField(name string) error {
	switch name {
	case chapter.FieldName:
		m.ResetName()
		return nil
	case chapter.FieldReleasedTime:
		m.ResetReleasedTime()
		return nil
	case chapter.FieldDescription:
		m.ResetDescription()
		return nil
	case chapter.FieldSort:
		m.ResetSort()
		return nil
	case chapter.FieldHasFreePreview:
		m.ResetHasFreePreview()
		return nil
	case chapter.FieldCourseID:
		m.ResetCourseID()
		return nil
	}
	return fmt.Errorf("unknown Chapter field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChapterMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.lessons != nil {
		edges = append(edges, chapter.EdgeLessons)
	}
	if m.course != nil {
		edges = append(edges, chapter.EdgeCourse)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChapterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case chapter.EdgeLessons:
		ids := make([]ent.Value, 0, len(m.lessons))
		for id := range m.lessons {
			ids = append(ids, id)
		}
		return ids
	case chapter.EdgeCourse:
		if id := m.course; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChapterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedlessons != nil {
		edges = append(edges, chapter.EdgeLessons)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChapterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case chapter.EdgeLessons:
		ids := make([]ent.Value, 0, len(m.removedlessons))
		for id := range m.removedlessons {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChapterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedlessons {
		edges = append(edges, chapter.EdgeLessons)
	}
	if m.clearedcourse {
		edges = append(edges, chapter.EdgeCourse)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChapterMutation) EdgeCleared(name string) bool {
	switch name {
	case chapter.EdgeLessons:
		return m.clearedlessons
	case chapter.EdgeCourse:
		return m.clearedcourse
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChapterMutation) ClearEdge(name string) error {
	switch name {
	case chapter.EdgeCourse:
		m.ClearCourse()
		return nil
	}
	return fmt.Errorf("unknown Chapter unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChapterMutation) ResetEdge(name string) error {
	switch name {
	case chapter.EdgeLessons:
		m.ResetLessons()
		return nil
	case chapter.EdgeCourse:
		m.ResetCourse()
		return nil
	}
	return fmt.Errorf("unknown Chapter edge %s", name)
}

// CourseMutation represents an operation that mutates the Course nodes in the graph.
type CourseMutation struct {
	config
	op              Op
	typ             string
	id              *int
	level           *int32
	addlevel        *int32
	updated_at      *time.Time
	name            *string
	detail          *string
	cover           *string
	price           *float32
	addprice        *float32
	tags            *string
	created_at      *time.Time
	status          *int32
	addstatus       *int32
	clearedFields   map[string]struct{}
	owner           *int
	clearedowner    bool
	chapters        map[int]struct{}
	removedchapters map[int]struct{}
	clearedchapters bool
	done            bool
	oldValue        func(context.Context) (*Course, error)
	predicates      []predicate.Course
}

var _ ent.Mutation = (*CourseMutation)(nil)

// courseOption allows management of the mutation configuration using functional options.
type courseOption func(*CourseMutation)

// newCourseMutation creates new mutation for the Course entity.
func newCourseMutation(c config, op Op, opts ...courseOption) *CourseMutation {
	m := &CourseMutation{
		config:        c,
		op:            op,
		typ:           TypeCourse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCourseID sets the ID field of the mutation.
func withCourseID(id int) courseOption {
	return func(m *CourseMutation) {
		var (
			err   error
			once  sync.Once
			value *Course
		)
		m.oldValue = func(ctx context.Context) (*Course, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Course.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCourse sets the old Course of the mutation.
func withCourse(node *Course) courseOption {
	return func(m *CourseMutation) {
		m.oldValue = func(context.Context) (*Course, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CourseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CourseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CourseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CourseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Course.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLevel sets the "level" field.
func (m *CourseMutation) SetLevel(i int32) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *CourseMutation) Level() (r int32, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldLevel(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *CourseMutation) AddLevel(i int32) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *CourseMutation) AddedLevel() (r int32, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *CourseMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CourseMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CourseMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CourseMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *CourseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CourseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CourseMutation) ResetName() {
	m.name = nil
}

// SetDetail sets the "detail" field.
func (m *CourseMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *CourseMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ResetDetail resets all changes to the "detail" field.
func (m *CourseMutation) ResetDetail() {
	m.detail = nil
}

// SetCover sets the "cover" field.
func (m *CourseMutation) SetCover(s string) {
	m.cover = &s
}

// Cover returns the value of the "cover" field in the mutation.
func (m *CourseMutation) Cover() (r string, exists bool) {
	v := m.cover
	if v == nil {
		return
	}
	return *v, true
}

// OldCover returns the old "cover" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCover(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCover: %w", err)
	}
	return oldValue.Cover, nil
}

// ResetCover resets all changes to the "cover" field.
func (m *CourseMutation) ResetCover() {
	m.cover = nil
}

// SetPrice sets the "price" field.
func (m *CourseMutation) SetPrice(f float32) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *CourseMutation) Price() (r float32, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldPrice(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *CourseMutation) AddPrice(f float32) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *CourseMutation) AddedPrice() (r float32, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *CourseMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// SetTags sets the "tags" field.
func (m *CourseMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *CourseMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *CourseMutation) ResetTags() {
	m.tags = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *CourseMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CourseMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CourseMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetStatus sets the "status" field.
func (m *CourseMutation) SetStatus(i int32) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *CourseMutation) Status() (r int32, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *CourseMutation) AddStatus(i int32) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *CourseMutation) AddedStatus() (r int32, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *CourseMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetCategoryID sets the "category_id" field.
func (m *CourseMutation) SetCategoryID(i int) {
	m.owner = &i
}

// CategoryID returns the value of the "category_id" field in the mutation.
func (m *CourseMutation) CategoryID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldCategoryID returns the old "category_id" field's value of the Course entity.
// If the Course object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CourseMutation) OldCategoryID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategoryID: %w", err)
	}
	return oldValue.CategoryID, nil
}

// ClearCategoryID clears the value of the "category_id" field.
func (m *CourseMutation) ClearCategoryID() {
	m.owner = nil
	m.clearedFields[course.FieldCategoryID] = struct{}{}
}

// CategoryIDCleared returns if the "category_id" field was cleared in this mutation.
func (m *CourseMutation) CategoryIDCleared() bool {
	_, ok := m.clearedFields[course.FieldCategoryID]
	return ok
}

// ResetCategoryID resets all changes to the "category_id" field.
func (m *CourseMutation) ResetCategoryID() {
	m.owner = nil
	delete(m.clearedFields, course.FieldCategoryID)
}

// SetOwnerID sets the "owner" edge to the Category entity by id.
func (m *CourseMutation) SetOwnerID(id int) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the Category entity.
func (m *CourseMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the Category entity was cleared.
func (m *CourseMutation) OwnerCleared() bool {
	return m.CategoryIDCleared() || m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *CourseMutation) OwnerID() (id int, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *CourseMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *CourseMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddChapterIDs adds the "chapters" edge to the Chapter entity by ids.
func (m *CourseMutation) AddChapterIDs(ids ...int) {
	if m.chapters == nil {
		m.chapters = make(map[int]struct{})
	}
	for i := range ids {
		m.chapters[ids[i]] = struct{}{}
	}
}

// ClearChapters clears the "chapters" edge to the Chapter entity.
func (m *CourseMutation) ClearChapters() {
	m.clearedchapters = true
}

// ChaptersCleared reports if the "chapters" edge to the Chapter entity was cleared.
func (m *CourseMutation) ChaptersCleared() bool {
	return m.clearedchapters
}

// RemoveChapterIDs removes the "chapters" edge to the Chapter entity by IDs.
func (m *CourseMutation) RemoveChapterIDs(ids ...int) {
	if m.removedchapters == nil {
		m.removedchapters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.chapters, ids[i])
		m.removedchapters[ids[i]] = struct{}{}
	}
}

// RemovedChapters returns the removed IDs of the "chapters" edge to the Chapter entity.
func (m *CourseMutation) RemovedChaptersIDs() (ids []int) {
	for id := range m.removedchapters {
		ids = append(ids, id)
	}
	return
}

// ChaptersIDs returns the "chapters" edge IDs in the mutation.
func (m *CourseMutation) ChaptersIDs() (ids []int) {
	for id := range m.chapters {
		ids = append(ids, id)
	}
	return
}

// ResetChapters resets all changes to the "chapters" edge.
func (m *CourseMutation) ResetChapters() {
	m.chapters = nil
	m.clearedchapters = false
	m.removedchapters = nil
}

// Where appends a list predicates to the CourseMutation builder.
func (m *CourseMutation) Where(ps ...predicate.Course) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CourseMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CourseMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Course, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CourseMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CourseMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Course).
func (m *CourseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CourseMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.level != nil {
		fields = append(fields, course.FieldLevel)
	}
	if m.updated_at != nil {
		fields = append(fields, course.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, course.FieldName)
	}
	if m.detail != nil {
		fields = append(fields, course.FieldDetail)
	}
	if m.cover != nil {
		fields = append(fields, course.FieldCover)
	}
	if m.price != nil {
		fields = append(fields, course.FieldPrice)
	}
	if m.tags != nil {
		fields = append(fields, course.FieldTags)
	}
	if m.created_at != nil {
		fields = append(fields, course.FieldCreatedAt)
	}
	if m.status != nil {
		fields = append(fields, course.FieldStatus)
	}
	if m.owner != nil {
		fields = append(fields, course.FieldCategoryID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CourseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case course.FieldLevel:
		return m.Level()
	case course.FieldUpdatedAt:
		return m.UpdatedAt()
	case course.FieldName:
		return m.Name()
	case course.FieldDetail:
		return m.Detail()
	case course.FieldCover:
		return m.Cover()
	case course.FieldPrice:
		return m.Price()
	case course.FieldTags:
		return m.Tags()
	case course.FieldCreatedAt:
		return m.CreatedAt()
	case course.FieldStatus:
		return m.Status()
	case course.FieldCategoryID:
		return m.CategoryID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CourseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case course.FieldLevel:
		return m.OldLevel(ctx)
	case course.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case course.FieldName:
		return m.OldName(ctx)
	case course.FieldDetail:
		return m.OldDetail(ctx)
	case course.FieldCover:
		return m.OldCover(ctx)
	case course.FieldPrice:
		return m.OldPrice(ctx)
	case course.FieldTags:
		return m.OldTags(ctx)
	case course.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case course.FieldStatus:
		return m.OldStatus(ctx)
	case course.FieldCategoryID:
		return m.OldCategoryID(ctx)
	}
	return nil, fmt.Errorf("unknown Course field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case course.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case course.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case course.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case course.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case course.FieldCover:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCover(v)
		return nil
	case course.FieldPrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	case course.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case course.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case course.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case course.FieldCategoryID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategoryID(v)
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CourseMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, course.FieldLevel)
	}
	if m.addprice != nil {
		fields = append(fields, course.FieldPrice)
	}
	if m.addstatus != nil {
		fields = append(fields, course.FieldStatus)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CourseMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case course.FieldLevel:
		return m.AddedLevel()
	case course.FieldPrice:
		return m.AddedPrice()
	case course.FieldStatus:
		return m.AddedStatus()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CourseMutation) AddField(name string, value ent.Value) error {
	switch name {
	case course.FieldLevel:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	case course.FieldPrice:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	case course.FieldStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Course numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CourseMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(course.FieldCategoryID) {
		fields = append(fields, course.FieldCategoryID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CourseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CourseMutation) ClearField(name string) error {
	switch name {
	case course.FieldCategoryID:
		m.ClearCategoryID()
		return nil
	}
	return fmt.Errorf("unknown Course nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CourseMutation) ResetField(name string) error {
	switch name {
	case course.FieldLevel:
		m.ResetLevel()
		return nil
	case course.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case course.FieldName:
		m.ResetName()
		return nil
	case course.FieldDetail:
		m.ResetDetail()
		return nil
	case course.FieldCover:
		m.ResetCover()
		return nil
	case course.FieldPrice:
		m.ResetPrice()
		return nil
	case course.FieldTags:
		m.ResetTags()
		return nil
	case course.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case course.FieldStatus:
		m.ResetStatus()
		return nil
	case course.FieldCategoryID:
		m.ResetCategoryID()
		return nil
	}
	return fmt.Errorf("unknown Course field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CourseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, course.EdgeOwner)
	}
	if m.chapters != nil {
		edges = append(edges, course.EdgeChapters)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CourseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case course.EdgeChapters:
		ids := make([]ent.Value, 0, len(m.chapters))
		for id := range m.chapters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CourseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchapters != nil {
		edges = append(edges, course.EdgeChapters)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CourseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case course.EdgeChapters:
		ids := make([]ent.Value, 0, len(m.removedchapters))
		for id := range m.removedchapters {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CourseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, course.EdgeOwner)
	}
	if m.clearedchapters {
		edges = append(edges, course.EdgeChapters)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CourseMutation) EdgeCleared(name string) bool {
	switch name {
	case course.EdgeOwner:
		return m.clearedowner
	case course.EdgeChapters:
		return m.clearedchapters
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CourseMutation) ClearEdge(name string) error {
	switch name {
	case course.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Course unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CourseMutation) ResetEdge(name string) error {
	switch name {
	case course.EdgeOwner:
		m.ResetOwner()
		return nil
	case course.EdgeChapters:
		m.ResetChapters()
		return nil
	}
	return fmt.Errorf("unknown Course edge %s", name)
}

// LessonMutation represents an operation that mutates the Lesson nodes in the graph.
type LessonMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	released_time      *time.Time
	sort               *int
	addsort            *int
	_type              *int
	add_type           *int
	storage_path       *string
	source             *string
	courseware         *string
	is_free_preview    *int
	addis_free_preview *int
	clearedFields      map[string]struct{}
	chapter            *int
	clearedchapter     bool
	done               bool
	oldValue           func(context.Context) (*Lesson, error)
	predicates         []predicate.Lesson
}

var _ ent.Mutation = (*LessonMutation)(nil)

// lessonOption allows management of the mutation configuration using functional options.
type lessonOption func(*LessonMutation)

// newLessonMutation creates new mutation for the Lesson entity.
func newLessonMutation(c config, op Op, opts ...lessonOption) *LessonMutation {
	m := &LessonMutation{
		config:        c,
		op:            op,
		typ:           TypeLesson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLessonID sets the ID field of the mutation.
func withLessonID(id int) lessonOption {
	return func(m *LessonMutation) {
		var (
			err   error
			once  sync.Once
			value *Lesson
		)
		m.oldValue = func(ctx context.Context) (*Lesson, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Lesson.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLesson sets the old Lesson of the mutation.
func withLesson(node *Lesson) lessonOption {
	return func(m *LessonMutation) {
		m.oldValue = func(context.Context) (*Lesson, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LessonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LessonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LessonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LessonMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Lesson.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LessonMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LessonMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LessonMutation) ResetName() {
	m.name = nil
}

// SetReleasedTime sets the "released_time" field.
func (m *LessonMutation) SetReleasedTime(t time.Time) {
	m.released_time = &t
}

// ReleasedTime returns the value of the "released_time" field in the mutation.
func (m *LessonMutation) ReleasedTime() (r time.Time, exists bool) {
	v := m.released_time
	if v == nil {
		return
	}
	return *v, true
}

// OldReleasedTime returns the old "released_time" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldReleasedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReleasedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReleasedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReleasedTime: %w", err)
	}
	return oldValue.ReleasedTime, nil
}

// ResetReleasedTime resets all changes to the "released_time" field.
func (m *LessonMutation) ResetReleasedTime() {
	m.released_time = nil
}

// SetSort sets the "sort" field.
func (m *LessonMutation) SetSort(i int) {
	m.sort = &i
	m.addsort = nil
}

// Sort returns the value of the "sort" field in the mutation.
func (m *LessonMutation) Sort() (r int, exists bool) {
	v := m.sort
	if v == nil {
		return
	}
	return *v, true
}

// OldSort returns the old "sort" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldSort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSort: %w", err)
	}
	return oldValue.Sort, nil
}

// AddSort adds i to the "sort" field.
func (m *LessonMutation) AddSort(i int) {
	if m.addsort != nil {
		*m.addsort += i
	} else {
		m.addsort = &i
	}
}

// AddedSort returns the value that was added to the "sort" field in this mutation.
func (m *LessonMutation) AddedSort() (r int, exists bool) {
	v := m.addsort
	if v == nil {
		return
	}
	return *v, true
}

// ResetSort resets all changes to the "sort" field.
func (m *LessonMutation) ResetSort() {
	m.sort = nil
	m.addsort = nil
}

// SetType sets the "type" field.
func (m *LessonMutation) SetType(i int) {
	m._type = &i
	m.add_type = nil
}

// GetType returns the value of the "type" field in the mutation.
func (m *LessonMutation) GetType() (r int, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldType(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// AddType adds i to the "type" field.
func (m *LessonMutation) AddType(i int) {
	if m.add_type != nil {
		*m.add_type += i
	} else {
		m.add_type = &i
	}
}

// AddedType returns the value that was added to the "type" field in this mutation.
func (m *LessonMutation) AddedType() (r int, exists bool) {
	v := m.add_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetType resets all changes to the "type" field.
func (m *LessonMutation) ResetType() {
	m._type = nil
	m.add_type = nil
}

// SetStoragePath sets the "storage_path" field.
func (m *LessonMutation) SetStoragePath(s string) {
	m.storage_path = &s
}

// StoragePath returns the value of the "storage_path" field in the mutation.
func (m *LessonMutation) StoragePath() (r string, exists bool) {
	v := m.storage_path
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePath returns the old "storage_path" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldStoragePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePath: %w", err)
	}
	return oldValue.StoragePath, nil
}

// ResetStoragePath resets all changes to the "storage_path" field.
func (m *LessonMutation) ResetStoragePath() {
	m.storage_path = nil
}

// SetSource sets the "source" field.
func (m *LessonMutation) SetSource(s string) {
	m.source = &s
}

// Source returns the value of the "source" field in the mutation.
func (m *LessonMutation) Source() (r string, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldSource(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *LessonMutation) ResetSource() {
	m.source = nil
}

// SetCourseware sets the "courseware" field.
func (m *LessonMutation) SetCourseware(s string) {
	m.courseware = &s
}

// Courseware returns the value of the "courseware" field in the mutation.
func (m *LessonMutation) Courseware() (r string, exists bool) {
	v := m.courseware
	if v == nil {
		return
	}
	return *v, true
}

// OldCourseware returns the old "courseware" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldCourseware(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCourseware is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCourseware requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCourseware: %w", err)
	}
	return oldValue.Courseware, nil
}

// ResetCourseware resets all changes to the "courseware" field.
func (m *LessonMutation) ResetCourseware() {
	m.courseware = nil
}

// SetIsFreePreview sets the "is_free_preview" field.
func (m *LessonMutation) SetIsFreePreview(i int) {
	m.is_free_preview = &i
	m.addis_free_preview = nil
}

// IsFreePreview returns the value of the "is_free_preview" field in the mutation.
func (m *LessonMutation) IsFreePreview() (r int, exists bool) {
	v := m.is_free_preview
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFreePreview returns the old "is_free_preview" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldIsFreePreview(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFreePreview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFreePreview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFreePreview: %w", err)
	}
	return oldValue.IsFreePreview, nil
}

// AddIsFreePreview adds i to the "is_free_preview" field.
func (m *LessonMutation) AddIsFreePreview(i int) {
	if m.addis_free_preview != nil {
		*m.addis_free_preview += i
	} else {
		m.addis_free_preview = &i
	}
}

// AddedIsFreePreview returns the value that was added to the "is_free_preview" field in this mutation.
func (m *LessonMutation) AddedIsFreePreview() (r int, exists bool) {
	v := m.addis_free_preview
	if v == nil {
		return
	}
	return *v, true
}

// ResetIsFreePreview resets all changes to the "is_free_preview" field.
func (m *LessonMutation) ResetIsFreePreview() {
	m.is_free_preview = nil
	m.addis_free_preview = nil
}

// SetChapterID sets the "chapter_id" field.
func (m *LessonMutation) SetChapterID(i int) {
	m.chapter = &i
}

// ChapterID returns the value of the "chapter_id" field in the mutation.
func (m *LessonMutation) ChapterID() (r int, exists bool) {
	v := m.chapter
	if v == nil {
		return
	}
	return *v, true
}

// OldChapterID returns the old "chapter_id" field's value of the Lesson entity.
// If the Lesson object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LessonMutation) OldChapterID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChapterID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChapterID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChapterID: %w", err)
	}
	return oldValue.ChapterID, nil
}

// ClearChapterID clears the value of the "chapter_id" field.
func (m *LessonMutation) ClearChapterID() {
	m.chapter = nil
	m.clearedFields[lesson.FieldChapterID] = struct{}{}
}

// ChapterIDCleared returns if the "chapter_id" field was cleared in this mutation.
func (m *LessonMutation) ChapterIDCleared() bool {
	_, ok := m.clearedFields[lesson.FieldChapterID]
	return ok
}

// ResetChapterID resets all changes to the "chapter_id" field.
func (m *LessonMutation) ResetChapterID() {
	m.chapter = nil
	delete(m.clearedFields, lesson.FieldChapterID)
}

// ClearChapter clears the "chapter" edge to the Chapter entity.
func (m *LessonMutation) ClearChapter() {
	m.clearedchapter = true
}

// ChapterCleared reports if the "chapter" edge to the Chapter entity was cleared.
func (m *LessonMutation) ChapterCleared() bool {
	return m.ChapterIDCleared() || m.clearedchapter
}

// ChapterIDs returns the "chapter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChapterID instead. It exists only for internal usage by the builders.
func (m *LessonMutation) ChapterIDs() (ids []int) {
	if id := m.chapter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChapter resets all changes to the "chapter" edge.
func (m *LessonMutation) ResetChapter() {
	m.chapter = nil
	m.clearedchapter = false
}

// Where appends a list predicates to the LessonMutation builder.
func (m *LessonMutation) Where(ps ...predicate.Lesson) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LessonMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LessonMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Lesson, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LessonMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LessonMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Lesson).
func (m *LessonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LessonMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.name != nil {
		fields = append(fields, lesson.FieldName)
	}
	if m.released_time != nil {
		fields = append(fields, lesson.FieldReleasedTime)
	}
	if m.sort != nil {
		fields = append(fields, lesson.FieldSort)
	}
	if m._type != nil {
		fields = append(fields, lesson.FieldType)
	}
	if m.storage_path != nil {
		fields = append(fields, lesson.FieldStoragePath)
	}
	if m.source != nil {
		fields = append(fields, lesson.FieldSource)
	}
	if m.courseware != nil {
		fields = append(fields, lesson.FieldCourseware)
	}
	if m.is_free_preview != nil {
		fields = append(fields, lesson.FieldIsFreePreview)
	}
	if m.chapter != nil {
		fields = append(fields, lesson.FieldChapterID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LessonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case lesson.FieldName:
		return m.Name()
	case lesson.FieldReleasedTime:
		return m.ReleasedTime()
	case lesson.FieldSort:
		return m.Sort()
	case lesson.FieldType:
		return m.GetType()
	case lesson.FieldStoragePath:
		return m.StoragePath()
	case lesson.FieldSource:
		return m.Source()
	case lesson.FieldCourseware:
		return m.Courseware()
	case lesson.FieldIsFreePreview:
		return m.IsFreePreview()
	case lesson.FieldChapterID:
		return m.ChapterID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LessonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case lesson.FieldName:
		return m.OldName(ctx)
	case lesson.FieldReleasedTime:
		return m.OldReleasedTime(ctx)
	case lesson.FieldSort:
		return m.OldSort(ctx)
	case lesson.FieldType:
		return m.OldType(ctx)
	case lesson.FieldStoragePath:
		return m.OldStoragePath(ctx)
	case lesson.FieldSource:
		return m.OldSource(ctx)
	case lesson.FieldCourseware:
		return m.OldCourseware(ctx)
	case lesson.FieldIsFreePreview:
		return m.OldIsFreePreview(ctx)
	case lesson.FieldChapterID:
		return m.OldChapterID(ctx)
	}
	return nil, fmt.Errorf("unknown Lesson field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case lesson.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case lesson.FieldReleasedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReleasedTime(v)
		return nil
	case lesson.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSort(v)
		return nil
	case lesson.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case lesson.FieldStoragePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePath(v)
		return nil
	case lesson.FieldSource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case lesson.FieldCourseware:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCourseware(v)
		return nil
	case lesson.FieldIsFreePreview:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFreePreview(v)
		return nil
	case lesson.FieldChapterID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChapterID(v)
		return nil
	}
	return fmt.Errorf("unknown Lesson field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LessonMutation) AddedFields() []string {
	var fields []string
	if m.addsort != nil {
		fields = append(fields, lesson.FieldSort)
	}
	if m.add_type != nil {
		fields = append(fields, lesson.FieldType)
	}
	if m.addis_free_preview != nil {
		fields = append(fields, lesson.FieldIsFreePreview)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LessonMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case lesson.FieldSort:
		return m.AddedSort()
	case lesson.FieldType:
		return m.AddedType()
	case lesson.FieldIsFreePreview:
		return m.AddedIsFreePreview()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LessonMutation) AddField(name string, value ent.Value) error {
	switch name {
	case lesson.FieldSort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSort(v)
		return nil
	case lesson.FieldType:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddType(v)
		return nil
	case lesson.FieldIsFreePreview:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIsFreePreview(v)
		return nil
	}
	return fmt.Errorf("unknown Lesson numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LessonMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(lesson.FieldChapterID) {
		fields = append(fields, lesson.FieldChapterID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LessonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LessonMutation) ClearField(name string) error {
	switch name {
	case lesson.FieldChapterID:
		m.ClearChapterID()
		return nil
	}
	return fmt.Errorf("unknown Lesson nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LessonMutation) ResetField(name string) error {
	switch name {
	case lesson.FieldName:
		m.ResetName()
		return nil
	case lesson.FieldReleasedTime:
		m.ResetReleasedTime()
		return nil
	case lesson.FieldSort:
		m.ResetSort()
		return nil
	case lesson.FieldType:
		m.ResetType()
		return nil
	case lesson.FieldStoragePath:
		m.ResetStoragePath()
		return nil
	case lesson.FieldSource:
		m.ResetSource()
		return nil
	case lesson.FieldCourseware:
		m.ResetCourseware()
		return nil
	case lesson.FieldIsFreePreview:
		m.ResetIsFreePreview()
		return nil
	case lesson.FieldChapterID:
		m.ResetChapterID()
		return nil
	}
	return fmt.Errorf("unknown Lesson field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LessonMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.chapter != nil {
		edges = append(edges, lesson.EdgeChapter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LessonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case lesson.EdgeChapter:
		if id := m.chapter; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LessonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LessonMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LessonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedchapter {
		edges = append(edges, lesson.EdgeChapter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LessonMutation) EdgeCleared(name string) bool {
	switch name {
	case lesson.EdgeChapter:
		return m.clearedchapter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LessonMutation) ClearEdge(name string) error {
	switch name {
	case lesson.EdgeChapter:
		m.ClearChapter()
		return nil
	}
	return fmt.Errorf("unknown Lesson unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LessonMutation) ResetEdge(name string) error {
	switch name {
	case lesson.EdgeChapter:
		m.ResetChapter()
		return nil
	}
	return fmt.Errorf("unknown Lesson edge %s", name)
}

// OrderInfosMutation represents an operation that mutates the OrderInfos nodes in the graph.
type OrderInfosMutation struct {
	config
	op               Op
	typ              string
	id               *int
	order_id         *int32
	addorder_id      *int32
	product_id       *int32
	addproduct_id    *int32
	product_name     *string
	product_price    *int32
	addproduct_price *int32
	product_describe *string
	create_time      *time.Time
	update_time      *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*OrderInfos, error)
	predicates       []predicate.OrderInfos
}

var _ ent.Mutation = (*OrderInfosMutation)(nil)

// orderinfosOption allows management of the mutation configuration using functional options.
type orderinfosOption func(*OrderInfosMutation)

// newOrderInfosMutation creates new mutation for the OrderInfos entity.
func newOrderInfosMutation(c config, op Op, opts ...orderinfosOption) *OrderInfosMutation {
	m := &OrderInfosMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderInfos,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderInfosID sets the ID field of the mutation.
func withOrderInfosID(id int) orderinfosOption {
	return func(m *OrderInfosMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderInfos
		)
		m.oldValue = func(ctx context.Context) (*OrderInfos, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderInfos.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderInfos sets the old OrderInfos of the mutation.
func withOrderInfos(node *OrderInfos) orderinfosOption {
	return func(m *OrderInfosMutation) {
		m.oldValue = func(context.Context) (*OrderInfos, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderInfosMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderInfosMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderInfosMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderInfosMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderInfos.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOrderID sets the "order_id" field.
func (m *OrderInfosMutation) SetOrderID(i int32) {
	m.order_id = &i
	m.addorder_id = nil
}

// OrderID returns the value of the "order_id" field in the mutation.
func (m *OrderInfosMutation) OrderID() (r int32, exists bool) {
	v := m.order_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderID returns the old "order_id" field's value of the OrderInfos entity.
// If the OrderInfos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfosMutation) OldOrderID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderID: %w", err)
	}
	return oldValue.OrderID, nil
}

// AddOrderID adds i to the "order_id" field.
func (m *OrderInfosMutation) AddOrderID(i int32) {
	if m.addorder_id != nil {
		*m.addorder_id += i
	} else {
		m.addorder_id = &i
	}
}

// AddedOrderID returns the value that was added to the "order_id" field in this mutation.
func (m *OrderInfosMutation) AddedOrderID() (r int32, exists bool) {
	v := m.addorder_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetOrderID resets all changes to the "order_id" field.
func (m *OrderInfosMutation) ResetOrderID() {
	m.order_id = nil
	m.addorder_id = nil
}

// SetProductID sets the "product_id" field.
func (m *OrderInfosMutation) SetProductID(i int32) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *OrderInfosMutation) ProductID() (r int32, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the OrderInfos entity.
// If the OrderInfos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfosMutation) OldProductID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *OrderInfosMutation) AddProductID(i int32) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *OrderInfosMutation) AddedProductID() (r int32, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductID resets all changes to the "product_id" field.
func (m *OrderInfosMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
}

// SetProductName sets the "product_name" field.
func (m *OrderInfosMutation) SetProductName(s string) {
	m.product_name = &s
}

// ProductName returns the value of the "product_name" field in the mutation.
func (m *OrderInfosMutation) ProductName() (r string, exists bool) {
	v := m.product_name
	if v == nil {
		return
	}
	return *v, true
}

// OldProductName returns the old "product_name" field's value of the OrderInfos entity.
// If the OrderInfos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfosMutation) OldProductName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductName: %w", err)
	}
	return oldValue.ProductName, nil
}

// ResetProductName resets all changes to the "product_name" field.
func (m *OrderInfosMutation) ResetProductName() {
	m.product_name = nil
}

// SetProductPrice sets the "product_price" field.
func (m *OrderInfosMutation) SetProductPrice(i int32) {
	m.product_price = &i
	m.addproduct_price = nil
}

// ProductPrice returns the value of the "product_price" field in the mutation.
func (m *OrderInfosMutation) ProductPrice() (r int32, exists bool) {
	v := m.product_price
	if v == nil {
		return
	}
	return *v, true
}

// OldProductPrice returns the old "product_price" field's value of the OrderInfos entity.
// If the OrderInfos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfosMutation) OldProductPrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductPrice: %w", err)
	}
	return oldValue.ProductPrice, nil
}

// AddProductPrice adds i to the "product_price" field.
func (m *OrderInfosMutation) AddProductPrice(i int32) {
	if m.addproduct_price != nil {
		*m.addproduct_price += i
	} else {
		m.addproduct_price = &i
	}
}

// AddedProductPrice returns the value that was added to the "product_price" field in this mutation.
func (m *OrderInfosMutation) AddedProductPrice() (r int32, exists bool) {
	v := m.addproduct_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetProductPrice resets all changes to the "product_price" field.
func (m *OrderInfosMutation) ResetProductPrice() {
	m.product_price = nil
	m.addproduct_price = nil
}

// SetProductDescribe sets the "product_describe" field.
func (m *OrderInfosMutation) SetProductDescribe(s string) {
	m.product_describe = &s
}

// ProductDescribe returns the value of the "product_describe" field in the mutation.
func (m *OrderInfosMutation) ProductDescribe() (r string, exists bool) {
	v := m.product_describe
	if v == nil {
		return
	}
	return *v, true
}

// OldProductDescribe returns the old "product_describe" field's value of the OrderInfos entity.
// If the OrderInfos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfosMutation) OldProductDescribe(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductDescribe is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductDescribe requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductDescribe: %w", err)
	}
	return oldValue.ProductDescribe, nil
}

// ResetProductDescribe resets all changes to the "product_describe" field.
func (m *OrderInfosMutation) ResetProductDescribe() {
	m.product_describe = nil
}

// SetCreateTime sets the "create_time" field.
func (m *OrderInfosMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrderInfosMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the OrderInfos entity.
// If the OrderInfos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfosMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrderInfosMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrderInfosMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrderInfosMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the OrderInfos entity.
// If the OrderInfos object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderInfosMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrderInfosMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the OrderInfosMutation builder.
func (m *OrderInfosMutation) Where(ps ...predicate.OrderInfos) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderInfosMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderInfosMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderInfos, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderInfosMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderInfosMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderInfos).
func (m *OrderInfosMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderInfosMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.order_id != nil {
		fields = append(fields, orderinfos.FieldOrderID)
	}
	if m.product_id != nil {
		fields = append(fields, orderinfos.FieldProductID)
	}
	if m.product_name != nil {
		fields = append(fields, orderinfos.FieldProductName)
	}
	if m.product_price != nil {
		fields = append(fields, orderinfos.FieldProductPrice)
	}
	if m.product_describe != nil {
		fields = append(fields, orderinfos.FieldProductDescribe)
	}
	if m.create_time != nil {
		fields = append(fields, orderinfos.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orderinfos.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderInfosMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderinfos.FieldOrderID:
		return m.OrderID()
	case orderinfos.FieldProductID:
		return m.ProductID()
	case orderinfos.FieldProductName:
		return m.ProductName()
	case orderinfos.FieldProductPrice:
		return m.ProductPrice()
	case orderinfos.FieldProductDescribe:
		return m.ProductDescribe()
	case orderinfos.FieldCreateTime:
		return m.CreateTime()
	case orderinfos.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderInfosMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderinfos.FieldOrderID:
		return m.OldOrderID(ctx)
	case orderinfos.FieldProductID:
		return m.OldProductID(ctx)
	case orderinfos.FieldProductName:
		return m.OldProductName(ctx)
	case orderinfos.FieldProductPrice:
		return m.OldProductPrice(ctx)
	case orderinfos.FieldProductDescribe:
		return m.OldProductDescribe(ctx)
	case orderinfos.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orderinfos.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown OrderInfos field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderInfosMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderinfos.FieldOrderID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderID(v)
		return nil
	case orderinfos.FieldProductID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case orderinfos.FieldProductName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductName(v)
		return nil
	case orderinfos.FieldProductPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductPrice(v)
		return nil
	case orderinfos.FieldProductDescribe:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductDescribe(v)
		return nil
	case orderinfos.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orderinfos.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown OrderInfos field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderInfosMutation) AddedFields() []string {
	var fields []string
	if m.addorder_id != nil {
		fields = append(fields, orderinfos.FieldOrderID)
	}
	if m.addproduct_id != nil {
		fields = append(fields, orderinfos.FieldProductID)
	}
	if m.addproduct_price != nil {
		fields = append(fields, orderinfos.FieldProductPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderInfosMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderinfos.FieldOrderID:
		return m.AddedOrderID()
	case orderinfos.FieldProductID:
		return m.AddedProductID()
	case orderinfos.FieldProductPrice:
		return m.AddedProductPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderInfosMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderinfos.FieldOrderID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrderID(v)
		return nil
	case orderinfos.FieldProductID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	case orderinfos.FieldProductPrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductPrice(v)
		return nil
	}
	return fmt.Errorf("unknown OrderInfos numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderInfosMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderInfosMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderInfosMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderInfos nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderInfosMutation) ResetField(name string) error {
	switch name {
	case orderinfos.FieldOrderID:
		m.ResetOrderID()
		return nil
	case orderinfos.FieldProductID:
		m.ResetProductID()
		return nil
	case orderinfos.FieldProductName:
		m.ResetProductName()
		return nil
	case orderinfos.FieldProductPrice:
		m.ResetProductPrice()
		return nil
	case orderinfos.FieldProductDescribe:
		m.ResetProductDescribe()
		return nil
	case orderinfos.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orderinfos.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown OrderInfos field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderInfosMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderInfosMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderInfosMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderInfosMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderInfosMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderInfosMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderInfosMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OrderInfos unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderInfosMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OrderInfos edge %s", name)
}

// OrdersMutation represents an operation that mutates the Orders nodes in the graph.
type OrdersMutation struct {
	config
	op             Op
	typ            string
	id             *int
	user_id        *int32
	adduser_id     *int32
	order_sn       *string
	pay_type       *int32
	addpay_type    *int32
	pay_status     *int32
	addpay_status  *int32
	trade_price    *int32
	addtrade_price *int32
	trade_no       *string
	pay_time       *time.Time
	create_time    *time.Time
	update_time    *time.Time
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Orders, error)
	predicates     []predicate.Orders
}

var _ ent.Mutation = (*OrdersMutation)(nil)

// ordersOption allows management of the mutation configuration using functional options.
type ordersOption func(*OrdersMutation)

// newOrdersMutation creates new mutation for the Orders entity.
func newOrdersMutation(c config, op Op, opts ...ordersOption) *OrdersMutation {
	m := &OrdersMutation{
		config:        c,
		op:            op,
		typ:           TypeOrders,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrdersID sets the ID field of the mutation.
func withOrdersID(id int) ordersOption {
	return func(m *OrdersMutation) {
		var (
			err   error
			once  sync.Once
			value *Orders
		)
		m.oldValue = func(ctx context.Context) (*Orders, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Orders.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrders sets the old Orders of the mutation.
func withOrders(node *Orders) ordersOption {
	return func(m *OrdersMutation) {
		m.oldValue = func(context.Context) (*Orders, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrdersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrdersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrdersMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrdersMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Orders.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUserID sets the "user_id" field.
func (m *OrdersMutation) SetUserID(i int32) {
	m.user_id = &i
	m.adduser_id = nil
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *OrdersMutation) UserID() (r int32, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldUserID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// AddUserID adds i to the "user_id" field.
func (m *OrdersMutation) AddUserID(i int32) {
	if m.adduser_id != nil {
		*m.adduser_id += i
	} else {
		m.adduser_id = &i
	}
}

// AddedUserID returns the value that was added to the "user_id" field in this mutation.
func (m *OrdersMutation) AddedUserID() (r int32, exists bool) {
	v := m.adduser_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetUserID resets all changes to the "user_id" field.
func (m *OrdersMutation) ResetUserID() {
	m.user_id = nil
	m.adduser_id = nil
}

// SetOrderSn sets the "order_sn" field.
func (m *OrdersMutation) SetOrderSn(s string) {
	m.order_sn = &s
}

// OrderSn returns the value of the "order_sn" field in the mutation.
func (m *OrdersMutation) OrderSn() (r string, exists bool) {
	v := m.order_sn
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderSn returns the old "order_sn" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldOrderSn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderSn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderSn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderSn: %w", err)
	}
	return oldValue.OrderSn, nil
}

// ResetOrderSn resets all changes to the "order_sn" field.
func (m *OrdersMutation) ResetOrderSn() {
	m.order_sn = nil
}

// SetPayType sets the "pay_type" field.
func (m *OrdersMutation) SetPayType(i int32) {
	m.pay_type = &i
	m.addpay_type = nil
}

// PayType returns the value of the "pay_type" field in the mutation.
func (m *OrdersMutation) PayType() (r int32, exists bool) {
	v := m.pay_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPayType returns the old "pay_type" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldPayType(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayType: %w", err)
	}
	return oldValue.PayType, nil
}

// AddPayType adds i to the "pay_type" field.
func (m *OrdersMutation) AddPayType(i int32) {
	if m.addpay_type != nil {
		*m.addpay_type += i
	} else {
		m.addpay_type = &i
	}
}

// AddedPayType returns the value that was added to the "pay_type" field in this mutation.
func (m *OrdersMutation) AddedPayType() (r int32, exists bool) {
	v := m.addpay_type
	if v == nil {
		return
	}
	return *v, true
}

// ResetPayType resets all changes to the "pay_type" field.
func (m *OrdersMutation) ResetPayType() {
	m.pay_type = nil
	m.addpay_type = nil
}

// SetPayStatus sets the "pay_status" field.
func (m *OrdersMutation) SetPayStatus(i int32) {
	m.pay_status = &i
	m.addpay_status = nil
}

// PayStatus returns the value of the "pay_status" field in the mutation.
func (m *OrdersMutation) PayStatus() (r int32, exists bool) {
	v := m.pay_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPayStatus returns the old "pay_status" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldPayStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayStatus: %w", err)
	}
	return oldValue.PayStatus, nil
}

// AddPayStatus adds i to the "pay_status" field.
func (m *OrdersMutation) AddPayStatus(i int32) {
	if m.addpay_status != nil {
		*m.addpay_status += i
	} else {
		m.addpay_status = &i
	}
}

// AddedPayStatus returns the value that was added to the "pay_status" field in this mutation.
func (m *OrdersMutation) AddedPayStatus() (r int32, exists bool) {
	v := m.addpay_status
	if v == nil {
		return
	}
	return *v, true
}

// ClearPayStatus clears the value of the "pay_status" field.
func (m *OrdersMutation) ClearPayStatus() {
	m.pay_status = nil
	m.addpay_status = nil
	m.clearedFields[orders.FieldPayStatus] = struct{}{}
}

// PayStatusCleared returns if the "pay_status" field was cleared in this mutation.
func (m *OrdersMutation) PayStatusCleared() bool {
	_, ok := m.clearedFields[orders.FieldPayStatus]
	return ok
}

// ResetPayStatus resets all changes to the "pay_status" field.
func (m *OrdersMutation) ResetPayStatus() {
	m.pay_status = nil
	m.addpay_status = nil
	delete(m.clearedFields, orders.FieldPayStatus)
}

// SetTradePrice sets the "trade_price" field.
func (m *OrdersMutation) SetTradePrice(i int32) {
	m.trade_price = &i
	m.addtrade_price = nil
}

// TradePrice returns the value of the "trade_price" field in the mutation.
func (m *OrdersMutation) TradePrice() (r int32, exists bool) {
	v := m.trade_price
	if v == nil {
		return
	}
	return *v, true
}

// OldTradePrice returns the old "trade_price" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldTradePrice(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTradePrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTradePrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradePrice: %w", err)
	}
	return oldValue.TradePrice, nil
}

// AddTradePrice adds i to the "trade_price" field.
func (m *OrdersMutation) AddTradePrice(i int32) {
	if m.addtrade_price != nil {
		*m.addtrade_price += i
	} else {
		m.addtrade_price = &i
	}
}

// AddedTradePrice returns the value that was added to the "trade_price" field in this mutation.
func (m *OrdersMutation) AddedTradePrice() (r int32, exists bool) {
	v := m.addtrade_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetTradePrice resets all changes to the "trade_price" field.
func (m *OrdersMutation) ResetTradePrice() {
	m.trade_price = nil
	m.addtrade_price = nil
}

// SetTradeNo sets the "trade_no" field.
func (m *OrdersMutation) SetTradeNo(s string) {
	m.trade_no = &s
}

// TradeNo returns the value of the "trade_no" field in the mutation.
func (m *OrdersMutation) TradeNo() (r string, exists bool) {
	v := m.trade_no
	if v == nil {
		return
	}
	return *v, true
}

// OldTradeNo returns the old "trade_no" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldTradeNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTradeNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTradeNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTradeNo: %w", err)
	}
	return oldValue.TradeNo, nil
}

// ClearTradeNo clears the value of the "trade_no" field.
func (m *OrdersMutation) ClearTradeNo() {
	m.trade_no = nil
	m.clearedFields[orders.FieldTradeNo] = struct{}{}
}

// TradeNoCleared returns if the "trade_no" field was cleared in this mutation.
func (m *OrdersMutation) TradeNoCleared() bool {
	_, ok := m.clearedFields[orders.FieldTradeNo]
	return ok
}

// ResetTradeNo resets all changes to the "trade_no" field.
func (m *OrdersMutation) ResetTradeNo() {
	m.trade_no = nil
	delete(m.clearedFields, orders.FieldTradeNo)
}

// SetPayTime sets the "pay_time" field.
func (m *OrdersMutation) SetPayTime(t time.Time) {
	m.pay_time = &t
}

// PayTime returns the value of the "pay_time" field in the mutation.
func (m *OrdersMutation) PayTime() (r time.Time, exists bool) {
	v := m.pay_time
	if v == nil {
		return
	}
	return *v, true
}

// OldPayTime returns the old "pay_time" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldPayTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayTime: %w", err)
	}
	return oldValue.PayTime, nil
}

// ClearPayTime clears the value of the "pay_time" field.
func (m *OrdersMutation) ClearPayTime() {
	m.pay_time = nil
	m.clearedFields[orders.FieldPayTime] = struct{}{}
}

// PayTimeCleared returns if the "pay_time" field was cleared in this mutation.
func (m *OrdersMutation) PayTimeCleared() bool {
	_, ok := m.clearedFields[orders.FieldPayTime]
	return ok
}

// ResetPayTime resets all changes to the "pay_time" field.
func (m *OrdersMutation) ResetPayTime() {
	m.pay_time = nil
	delete(m.clearedFields, orders.FieldPayTime)
}

// SetCreateTime sets the "create_time" field.
func (m *OrdersMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *OrdersMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *OrdersMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *OrdersMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *OrdersMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Orders entity.
// If the Orders object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrdersMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *OrdersMutation) ResetUpdateTime() {
	m.update_time = nil
}

// Where appends a list predicates to the OrdersMutation builder.
func (m *OrdersMutation) Where(ps ...predicate.Orders) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrdersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrdersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Orders, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrdersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrdersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Orders).
func (m *OrdersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrdersMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.user_id != nil {
		fields = append(fields, orders.FieldUserID)
	}
	if m.order_sn != nil {
		fields = append(fields, orders.FieldOrderSn)
	}
	if m.pay_type != nil {
		fields = append(fields, orders.FieldPayType)
	}
	if m.pay_status != nil {
		fields = append(fields, orders.FieldPayStatus)
	}
	if m.trade_price != nil {
		fields = append(fields, orders.FieldTradePrice)
	}
	if m.trade_no != nil {
		fields = append(fields, orders.FieldTradeNo)
	}
	if m.pay_time != nil {
		fields = append(fields, orders.FieldPayTime)
	}
	if m.create_time != nil {
		fields = append(fields, orders.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, orders.FieldUpdateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrdersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orders.FieldUserID:
		return m.UserID()
	case orders.FieldOrderSn:
		return m.OrderSn()
	case orders.FieldPayType:
		return m.PayType()
	case orders.FieldPayStatus:
		return m.PayStatus()
	case orders.FieldTradePrice:
		return m.TradePrice()
	case orders.FieldTradeNo:
		return m.TradeNo()
	case orders.FieldPayTime:
		return m.PayTime()
	case orders.FieldCreateTime:
		return m.CreateTime()
	case orders.FieldUpdateTime:
		return m.UpdateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrdersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orders.FieldUserID:
		return m.OldUserID(ctx)
	case orders.FieldOrderSn:
		return m.OldOrderSn(ctx)
	case orders.FieldPayType:
		return m.OldPayType(ctx)
	case orders.FieldPayStatus:
		return m.OldPayStatus(ctx)
	case orders.FieldTradePrice:
		return m.OldTradePrice(ctx)
	case orders.FieldTradeNo:
		return m.OldTradeNo(ctx)
	case orders.FieldPayTime:
		return m.OldPayTime(ctx)
	case orders.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case orders.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Orders field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrdersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orders.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case orders.FieldOrderSn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderSn(v)
		return nil
	case orders.FieldPayType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayType(v)
		return nil
	case orders.FieldPayStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayStatus(v)
		return nil
	case orders.FieldTradePrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradePrice(v)
		return nil
	case orders.FieldTradeNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTradeNo(v)
		return nil
	case orders.FieldPayTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayTime(v)
		return nil
	case orders.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case orders.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Orders field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrdersMutation) AddedFields() []string {
	var fields []string
	if m.adduser_id != nil {
		fields = append(fields, orders.FieldUserID)
	}
	if m.addpay_type != nil {
		fields = append(fields, orders.FieldPayType)
	}
	if m.addpay_status != nil {
		fields = append(fields, orders.FieldPayStatus)
	}
	if m.addtrade_price != nil {
		fields = append(fields, orders.FieldTradePrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrdersMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orders.FieldUserID:
		return m.AddedUserID()
	case orders.FieldPayType:
		return m.AddedPayType()
	case orders.FieldPayStatus:
		return m.AddedPayStatus()
	case orders.FieldTradePrice:
		return m.AddedTradePrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrdersMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orders.FieldUserID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUserID(v)
		return nil
	case orders.FieldPayType:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayType(v)
		return nil
	case orders.FieldPayStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPayStatus(v)
		return nil
	case orders.FieldTradePrice:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTradePrice(v)
		return nil
	}
	return fmt.Errorf("unknown Orders numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrdersMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orders.FieldPayStatus) {
		fields = append(fields, orders.FieldPayStatus)
	}
	if m.FieldCleared(orders.FieldTradeNo) {
		fields = append(fields, orders.FieldTradeNo)
	}
	if m.FieldCleared(orders.FieldPayTime) {
		fields = append(fields, orders.FieldPayTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrdersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrdersMutation) ClearField(name string) error {
	switch name {
	case orders.FieldPayStatus:
		m.ClearPayStatus()
		return nil
	case orders.FieldTradeNo:
		m.ClearTradeNo()
		return nil
	case orders.FieldPayTime:
		m.ClearPayTime()
		return nil
	}
	return fmt.Errorf("unknown Orders nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrdersMutation) ResetField(name string) error {
	switch name {
	case orders.FieldUserID:
		m.ResetUserID()
		return nil
	case orders.FieldOrderSn:
		m.ResetOrderSn()
		return nil
	case orders.FieldPayType:
		m.ResetPayType()
		return nil
	case orders.FieldPayStatus:
		m.ResetPayStatus()
		return nil
	case orders.FieldTradePrice:
		m.ResetTradePrice()
		return nil
	case orders.FieldTradeNo:
		m.ResetTradeNo()
		return nil
	case orders.FieldPayTime:
		m.ResetPayTime()
		return nil
	case orders.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case orders.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	}
	return fmt.Errorf("unknown Orders field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrdersMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrdersMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrdersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrdersMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrdersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrdersMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrdersMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Orders unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrdersMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Orders edge %s", name)
}

// SettingMutation represents an operation that mutates the Setting nodes in the graph.
type SettingMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	detail        *string
	cover         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Setting, error)
	predicates    []predicate.Setting
}

var _ ent.Mutation = (*SettingMutation)(nil)

// settingOption allows management of the mutation configuration using functional options.
type settingOption func(*SettingMutation)

// newSettingMutation creates new mutation for the Setting entity.
func newSettingMutation(c config, op Op, opts ...settingOption) *SettingMutation {
	m := &SettingMutation{
		config:        c,
		op:            op,
		typ:           TypeSetting,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingID sets the ID field of the mutation.
func withSettingID(id int) settingOption {
	return func(m *SettingMutation) {
		var (
			err   error
			once  sync.Once
			value *Setting
		)
		m.oldValue = func(ctx context.Context) (*Setting, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Setting.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSetting sets the old Setting of the mutation.
func withSetting(node *Setting) settingOption {
	return func(m *SettingMutation) {
		m.oldValue = func(context.Context) (*Setting, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Setting.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *SettingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SettingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SettingMutation) ResetName() {
	m.name = nil
}

// SetDetail sets the "detail" field.
func (m *SettingMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *SettingMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ResetDetail resets all changes to the "detail" field.
func (m *SettingMutation) ResetDetail() {
	m.detail = nil
}

// SetCover sets the "cover" field.
func (m *SettingMutation) SetCover(s string) {
	m.cover = &s
}

// Cover returns the value of the "cover" field in the mutation.
func (m *SettingMutation) Cover() (r string, exists bool) {
	v := m.cover
	if v == nil {
		return
	}
	return *v, true
}

// OldCover returns the old "cover" field's value of the Setting entity.
// If the Setting object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingMutation) OldCover(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCover is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCover requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCover: %w", err)
	}
	return oldValue.Cover, nil
}

// ResetCover resets all changes to the "cover" field.
func (m *SettingMutation) ResetCover() {
	m.cover = nil
}

// Where appends a list predicates to the SettingMutation builder.
func (m *SettingMutation) Where(ps ...predicate.Setting) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Setting, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Setting).
func (m *SettingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, setting.FieldName)
	}
	if m.detail != nil {
		fields = append(fields, setting.FieldDetail)
	}
	if m.cover != nil {
		fields = append(fields, setting.FieldCover)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case setting.FieldName:
		return m.Name()
	case setting.FieldDetail:
		return m.Detail()
	case setting.FieldCover:
		return m.Cover()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case setting.FieldName:
		return m.OldName(ctx)
	case setting.FieldDetail:
		return m.OldDetail(ctx)
	case setting.FieldCover:
		return m.OldCover(ctx)
	}
	return nil, fmt.Errorf("unknown Setting field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case setting.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case setting.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case setting.FieldCover:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCover(v)
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Setting numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Setting nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingMutation) ResetField(name string) error {
	switch name {
	case setting.FieldName:
		m.ResetName()
		return nil
	case setting.FieldDetail:
		m.ResetDetail()
		return nil
	case setting.FieldCover:
		m.ResetCover()
		return nil
	}
	return fmt.Errorf("unknown Setting field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Setting unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Setting edge %s", name)
}

// SliderMutation represents an operation that mutates the Slider nodes in the graph.
type SliderMutation struct {
	config
	op            Op
	typ           string
	id            *int
	title         *string
	content       *string
	image_link    *string
	create_at     *time.Time
	update_at     *time.Time
	is_valid      *bool
	priority      *int
	addpriority   *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Slider, error)
	predicates    []predicate.Slider
}

var _ ent.Mutation = (*SliderMutation)(nil)

// sliderOption allows management of the mutation configuration using functional options.
type sliderOption func(*SliderMutation)

// newSliderMutation creates new mutation for the Slider entity.
func newSliderMutation(c config, op Op, opts ...sliderOption) *SliderMutation {
	m := &SliderMutation{
		config:        c,
		op:            op,
		typ:           TypeSlider,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSliderID sets the ID field of the mutation.
func withSliderID(id int) sliderOption {
	return func(m *SliderMutation) {
		var (
			err   error
			once  sync.Once
			value *Slider
		)
		m.oldValue = func(ctx context.Context) (*Slider, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Slider.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSlider sets the old Slider of the mutation.
func withSlider(node *Slider) sliderOption {
	return func(m *SliderMutation) {
		m.oldValue = func(context.Context) (*Slider, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SliderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SliderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SliderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SliderMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Slider.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *SliderMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *SliderMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *SliderMutation) ResetTitle() {
	m.title = nil
}

// SetContent sets the "content" field.
func (m *SliderMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *SliderMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *SliderMutation) ResetContent() {
	m.content = nil
}

// SetImageLink sets the "image_link" field.
func (m *SliderMutation) SetImageLink(s string) {
	m.image_link = &s
}

// ImageLink returns the value of the "image_link" field in the mutation.
func (m *SliderMutation) ImageLink() (r string, exists bool) {
	v := m.image_link
	if v == nil {
		return
	}
	return *v, true
}

// OldImageLink returns the old "image_link" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldImageLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageLink: %w", err)
	}
	return oldValue.ImageLink, nil
}

// ResetImageLink resets all changes to the "image_link" field.
func (m *SliderMutation) ResetImageLink() {
	m.image_link = nil
}

// SetCreateAt sets the "create_at" field.
func (m *SliderMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *SliderMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *SliderMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *SliderMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *SliderMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *SliderMutation) ResetUpdateAt() {
	m.update_at = nil
}

// SetIsValid sets the "is_valid" field.
func (m *SliderMutation) SetIsValid(b bool) {
	m.is_valid = &b
}

// IsValid returns the value of the "is_valid" field in the mutation.
func (m *SliderMutation) IsValid() (r bool, exists bool) {
	v := m.is_valid
	if v == nil {
		return
	}
	return *v, true
}

// OldIsValid returns the old "is_valid" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldIsValid(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsValid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsValid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsValid: %w", err)
	}
	return oldValue.IsValid, nil
}

// ResetIsValid resets all changes to the "is_valid" field.
func (m *SliderMutation) ResetIsValid() {
	m.is_valid = nil
}

// SetPriority sets the "priority" field.
func (m *SliderMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *SliderMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Slider entity.
// If the Slider object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SliderMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *SliderMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *SliderMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *SliderMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// Where appends a list predicates to the SliderMutation builder.
func (m *SliderMutation) Where(ps ...predicate.Slider) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SliderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SliderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Slider, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SliderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SliderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Slider).
func (m *SliderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SliderMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.title != nil {
		fields = append(fields, slider.FieldTitle)
	}
	if m.content != nil {
		fields = append(fields, slider.FieldContent)
	}
	if m.image_link != nil {
		fields = append(fields, slider.FieldImageLink)
	}
	if m.create_at != nil {
		fields = append(fields, slider.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, slider.FieldUpdateAt)
	}
	if m.is_valid != nil {
		fields = append(fields, slider.FieldIsValid)
	}
	if m.priority != nil {
		fields = append(fields, slider.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SliderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case slider.FieldTitle:
		return m.Title()
	case slider.FieldContent:
		return m.Content()
	case slider.FieldImageLink:
		return m.ImageLink()
	case slider.FieldCreateAt:
		return m.CreateAt()
	case slider.FieldUpdateAt:
		return m.UpdateAt()
	case slider.FieldIsValid:
		return m.IsValid()
	case slider.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SliderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case slider.FieldTitle:
		return m.OldTitle(ctx)
	case slider.FieldContent:
		return m.OldContent(ctx)
	case slider.FieldImageLink:
		return m.OldImageLink(ctx)
	case slider.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case slider.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	case slider.FieldIsValid:
		return m.OldIsValid(ctx)
	case slider.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown Slider field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SliderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case slider.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case slider.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case slider.FieldImageLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageLink(v)
		return nil
	case slider.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case slider.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	case slider.FieldIsValid:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsValid(v)
		return nil
	case slider.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Slider field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SliderMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, slider.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SliderMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case slider.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SliderMutation) AddField(name string, value ent.Value) error {
	switch name {
	case slider.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Slider numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SliderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SliderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SliderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Slider nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SliderMutation) ResetField(name string) error {
	switch name {
	case slider.FieldTitle:
		m.ResetTitle()
		return nil
	case slider.FieldContent:
		m.ResetContent()
		return nil
	case slider.FieldImageLink:
		m.ResetImageLink()
		return nil
	case slider.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case slider.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	case slider.FieldIsValid:
		m.ResetIsValid()
		return nil
	case slider.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown Slider field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SliderMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SliderMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SliderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SliderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SliderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SliderMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SliderMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Slider unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SliderMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Slider edge %s", name)
}

// TeacherMutation represents an operation that mutates the Teacher nodes in the graph.
type TeacherMutation struct {
	config
	op               Op
	typ              string
	id               *int
	detail           *string
	curriculum_vitae *string
	works            *string
	skills           *string
	name             *string
	level            *int
	addlevel         *int
	avator           *string
	create_at        *time.Time
	update_at        *time.Time
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Teacher, error)
	predicates       []predicate.Teacher
}

var _ ent.Mutation = (*TeacherMutation)(nil)

// teacherOption allows management of the mutation configuration using functional options.
type teacherOption func(*TeacherMutation)

// newTeacherMutation creates new mutation for the Teacher entity.
func newTeacherMutation(c config, op Op, opts ...teacherOption) *TeacherMutation {
	m := &TeacherMutation{
		config:        c,
		op:            op,
		typ:           TypeTeacher,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeacherID sets the ID field of the mutation.
func withTeacherID(id int) teacherOption {
	return func(m *TeacherMutation) {
		var (
			err   error
			once  sync.Once
			value *Teacher
		)
		m.oldValue = func(ctx context.Context) (*Teacher, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Teacher.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeacher sets the old Teacher of the mutation.
func withTeacher(node *Teacher) teacherOption {
	return func(m *TeacherMutation) {
		m.oldValue = func(context.Context) (*Teacher, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeacherMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeacherMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeacherMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeacherMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Teacher.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDetail sets the "detail" field.
func (m *TeacherMutation) SetDetail(s string) {
	m.detail = &s
}

// Detail returns the value of the "detail" field in the mutation.
func (m *TeacherMutation) Detail() (r string, exists bool) {
	v := m.detail
	if v == nil {
		return
	}
	return *v, true
}

// OldDetail returns the old "detail" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDetail: %w", err)
	}
	return oldValue.Detail, nil
}

// ClearDetail clears the value of the "detail" field.
func (m *TeacherMutation) ClearDetail() {
	m.detail = nil
	m.clearedFields[teacher.FieldDetail] = struct{}{}
}

// DetailCleared returns if the "detail" field was cleared in this mutation.
func (m *TeacherMutation) DetailCleared() bool {
	_, ok := m.clearedFields[teacher.FieldDetail]
	return ok
}

// ResetDetail resets all changes to the "detail" field.
func (m *TeacherMutation) ResetDetail() {
	m.detail = nil
	delete(m.clearedFields, teacher.FieldDetail)
}

// SetCurriculumVitae sets the "curriculum_vitae" field.
func (m *TeacherMutation) SetCurriculumVitae(s string) {
	m.curriculum_vitae = &s
}

// CurriculumVitae returns the value of the "curriculum_vitae" field in the mutation.
func (m *TeacherMutation) CurriculumVitae() (r string, exists bool) {
	v := m.curriculum_vitae
	if v == nil {
		return
	}
	return *v, true
}

// OldCurriculumVitae returns the old "curriculum_vitae" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldCurriculumVitae(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurriculumVitae is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurriculumVitae requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurriculumVitae: %w", err)
	}
	return oldValue.CurriculumVitae, nil
}

// ClearCurriculumVitae clears the value of the "curriculum_vitae" field.
func (m *TeacherMutation) ClearCurriculumVitae() {
	m.curriculum_vitae = nil
	m.clearedFields[teacher.FieldCurriculumVitae] = struct{}{}
}

// CurriculumVitaeCleared returns if the "curriculum_vitae" field was cleared in this mutation.
func (m *TeacherMutation) CurriculumVitaeCleared() bool {
	_, ok := m.clearedFields[teacher.FieldCurriculumVitae]
	return ok
}

// ResetCurriculumVitae resets all changes to the "curriculum_vitae" field.
func (m *TeacherMutation) ResetCurriculumVitae() {
	m.curriculum_vitae = nil
	delete(m.clearedFields, teacher.FieldCurriculumVitae)
}

// SetWorks sets the "works" field.
func (m *TeacherMutation) SetWorks(s string) {
	m.works = &s
}

// Works returns the value of the "works" field in the mutation.
func (m *TeacherMutation) Works() (r string, exists bool) {
	v := m.works
	if v == nil {
		return
	}
	return *v, true
}

// OldWorks returns the old "works" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldWorks(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorks: %w", err)
	}
	return oldValue.Works, nil
}

// ClearWorks clears the value of the "works" field.
func (m *TeacherMutation) ClearWorks() {
	m.works = nil
	m.clearedFields[teacher.FieldWorks] = struct{}{}
}

// WorksCleared returns if the "works" field was cleared in this mutation.
func (m *TeacherMutation) WorksCleared() bool {
	_, ok := m.clearedFields[teacher.FieldWorks]
	return ok
}

// ResetWorks resets all changes to the "works" field.
func (m *TeacherMutation) ResetWorks() {
	m.works = nil
	delete(m.clearedFields, teacher.FieldWorks)
}

// SetSkills sets the "skills" field.
func (m *TeacherMutation) SetSkills(s string) {
	m.skills = &s
}

// Skills returns the value of the "skills" field in the mutation.
func (m *TeacherMutation) Skills() (r string, exists bool) {
	v := m.skills
	if v == nil {
		return
	}
	return *v, true
}

// OldSkills returns the old "skills" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldSkills(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSkills is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSkills requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSkills: %w", err)
	}
	return oldValue.Skills, nil
}

// ClearSkills clears the value of the "skills" field.
func (m *TeacherMutation) ClearSkills() {
	m.skills = nil
	m.clearedFields[teacher.FieldSkills] = struct{}{}
}

// SkillsCleared returns if the "skills" field was cleared in this mutation.
func (m *TeacherMutation) SkillsCleared() bool {
	_, ok := m.clearedFields[teacher.FieldSkills]
	return ok
}

// ResetSkills resets all changes to the "skills" field.
func (m *TeacherMutation) ResetSkills() {
	m.skills = nil
	delete(m.clearedFields, teacher.FieldSkills)
}

// SetName sets the "name" field.
func (m *TeacherMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeacherMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeacherMutation) ResetName() {
	m.name = nil
}

// SetLevel sets the "level" field.
func (m *TeacherMutation) SetLevel(i int) {
	m.level = &i
	m.addlevel = nil
}

// Level returns the value of the "level" field in the mutation.
func (m *TeacherMutation) Level() (r int, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldLevel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// AddLevel adds i to the "level" field.
func (m *TeacherMutation) AddLevel(i int) {
	if m.addlevel != nil {
		*m.addlevel += i
	} else {
		m.addlevel = &i
	}
}

// AddedLevel returns the value that was added to the "level" field in this mutation.
func (m *TeacherMutation) AddedLevel() (r int, exists bool) {
	v := m.addlevel
	if v == nil {
		return
	}
	return *v, true
}

// ResetLevel resets all changes to the "level" field.
func (m *TeacherMutation) ResetLevel() {
	m.level = nil
	m.addlevel = nil
}

// SetAvator sets the "avator" field.
func (m *TeacherMutation) SetAvator(s string) {
	m.avator = &s
}

// Avator returns the value of the "avator" field in the mutation.
func (m *TeacherMutation) Avator() (r string, exists bool) {
	v := m.avator
	if v == nil {
		return
	}
	return *v, true
}

// OldAvator returns the old "avator" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldAvator(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvator is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvator requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvator: %w", err)
	}
	return oldValue.Avator, nil
}

// ClearAvator clears the value of the "avator" field.
func (m *TeacherMutation) ClearAvator() {
	m.avator = nil
	m.clearedFields[teacher.FieldAvator] = struct{}{}
}

// AvatorCleared returns if the "avator" field was cleared in this mutation.
func (m *TeacherMutation) AvatorCleared() bool {
	_, ok := m.clearedFields[teacher.FieldAvator]
	return ok
}

// ResetAvator resets all changes to the "avator" field.
func (m *TeacherMutation) ResetAvator() {
	m.avator = nil
	delete(m.clearedFields, teacher.FieldAvator)
}

// SetCreateAt sets the "create_at" field.
func (m *TeacherMutation) SetCreateAt(t time.Time) {
	m.create_at = &t
}

// CreateAt returns the value of the "create_at" field in the mutation.
func (m *TeacherMutation) CreateAt() (r time.Time, exists bool) {
	v := m.create_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateAt returns the old "create_at" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldCreateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateAt: %w", err)
	}
	return oldValue.CreateAt, nil
}

// ResetCreateAt resets all changes to the "create_at" field.
func (m *TeacherMutation) ResetCreateAt() {
	m.create_at = nil
}

// SetUpdateAt sets the "update_at" field.
func (m *TeacherMutation) SetUpdateAt(t time.Time) {
	m.update_at = &t
}

// UpdateAt returns the value of the "update_at" field in the mutation.
func (m *TeacherMutation) UpdateAt() (r time.Time, exists bool) {
	v := m.update_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateAt returns the old "update_at" field's value of the Teacher entity.
// If the Teacher object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeacherMutation) OldUpdateAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdateAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdateAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateAt: %w", err)
	}
	return oldValue.UpdateAt, nil
}

// ResetUpdateAt resets all changes to the "update_at" field.
func (m *TeacherMutation) ResetUpdateAt() {
	m.update_at = nil
}

// Where appends a list predicates to the TeacherMutation builder.
func (m *TeacherMutation) Where(ps ...predicate.Teacher) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeacherMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeacherMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Teacher, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeacherMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeacherMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Teacher).
func (m *TeacherMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeacherMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.detail != nil {
		fields = append(fields, teacher.FieldDetail)
	}
	if m.curriculum_vitae != nil {
		fields = append(fields, teacher.FieldCurriculumVitae)
	}
	if m.works != nil {
		fields = append(fields, teacher.FieldWorks)
	}
	if m.skills != nil {
		fields = append(fields, teacher.FieldSkills)
	}
	if m.name != nil {
		fields = append(fields, teacher.FieldName)
	}
	if m.level != nil {
		fields = append(fields, teacher.FieldLevel)
	}
	if m.avator != nil {
		fields = append(fields, teacher.FieldAvator)
	}
	if m.create_at != nil {
		fields = append(fields, teacher.FieldCreateAt)
	}
	if m.update_at != nil {
		fields = append(fields, teacher.FieldUpdateAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeacherMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case teacher.FieldDetail:
		return m.Detail()
	case teacher.FieldCurriculumVitae:
		return m.CurriculumVitae()
	case teacher.FieldWorks:
		return m.Works()
	case teacher.FieldSkills:
		return m.Skills()
	case teacher.FieldName:
		return m.Name()
	case teacher.FieldLevel:
		return m.Level()
	case teacher.FieldAvator:
		return m.Avator()
	case teacher.FieldCreateAt:
		return m.CreateAt()
	case teacher.FieldUpdateAt:
		return m.UpdateAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeacherMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case teacher.FieldDetail:
		return m.OldDetail(ctx)
	case teacher.FieldCurriculumVitae:
		return m.OldCurriculumVitae(ctx)
	case teacher.FieldWorks:
		return m.OldWorks(ctx)
	case teacher.FieldSkills:
		return m.OldSkills(ctx)
	case teacher.FieldName:
		return m.OldName(ctx)
	case teacher.FieldLevel:
		return m.OldLevel(ctx)
	case teacher.FieldAvator:
		return m.OldAvator(ctx)
	case teacher.FieldCreateAt:
		return m.OldCreateAt(ctx)
	case teacher.FieldUpdateAt:
		return m.OldUpdateAt(ctx)
	}
	return nil, fmt.Errorf("unknown Teacher field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeacherMutation) SetField(name string, value ent.Value) error {
	switch name {
	case teacher.FieldDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDetail(v)
		return nil
	case teacher.FieldCurriculumVitae:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurriculumVitae(v)
		return nil
	case teacher.FieldWorks:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorks(v)
		return nil
	case teacher.FieldSkills:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSkills(v)
		return nil
	case teacher.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case teacher.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case teacher.FieldAvator:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvator(v)
		return nil
	case teacher.FieldCreateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateAt(v)
		return nil
	case teacher.FieldUpdateAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateAt(v)
		return nil
	}
	return fmt.Errorf("unknown Teacher field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeacherMutation) AddedFields() []string {
	var fields []string
	if m.addlevel != nil {
		fields = append(fields, teacher.FieldLevel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeacherMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case teacher.FieldLevel:
		return m.AddedLevel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeacherMutation) AddField(name string, value ent.Value) error {
	switch name {
	case teacher.FieldLevel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLevel(v)
		return nil
	}
	return fmt.Errorf("unknown Teacher numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeacherMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(teacher.FieldDetail) {
		fields = append(fields, teacher.FieldDetail)
	}
	if m.FieldCleared(teacher.FieldCurriculumVitae) {
		fields = append(fields, teacher.FieldCurriculumVitae)
	}
	if m.FieldCleared(teacher.FieldWorks) {
		fields = append(fields, teacher.FieldWorks)
	}
	if m.FieldCleared(teacher.FieldSkills) {
		fields = append(fields, teacher.FieldSkills)
	}
	if m.FieldCleared(teacher.FieldAvator) {
		fields = append(fields, teacher.FieldAvator)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeacherMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeacherMutation) ClearField(name string) error {
	switch name {
	case teacher.FieldDetail:
		m.ClearDetail()
		return nil
	case teacher.FieldCurriculumVitae:
		m.ClearCurriculumVitae()
		return nil
	case teacher.FieldWorks:
		m.ClearWorks()
		return nil
	case teacher.FieldSkills:
		m.ClearSkills()
		return nil
	case teacher.FieldAvator:
		m.ClearAvator()
		return nil
	}
	return fmt.Errorf("unknown Teacher nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeacherMutation) ResetField(name string) error {
	switch name {
	case teacher.FieldDetail:
		m.ResetDetail()
		return nil
	case teacher.FieldCurriculumVitae:
		m.ResetCurriculumVitae()
		return nil
	case teacher.FieldWorks:
		m.ResetWorks()
		return nil
	case teacher.FieldSkills:
		m.ResetSkills()
		return nil
	case teacher.FieldName:
		m.ResetName()
		return nil
	case teacher.FieldLevel:
		m.ResetLevel()
		return nil
	case teacher.FieldAvator:
		m.ResetAvator()
		return nil
	case teacher.FieldCreateAt:
		m.ResetCreateAt()
		return nil
	case teacher.FieldUpdateAt:
		m.ResetUpdateAt()
		return nil
	}
	return fmt.Errorf("unknown Teacher field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeacherMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeacherMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeacherMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeacherMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeacherMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeacherMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeacherMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Teacher unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeacherMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Teacher edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	username      *string
	channel       *string
	role_id       *uint8
	addrole_id    *int8
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetChannel sets the "channel" field.
func (m *UserMutation) SetChannel(s string) {
	m.channel = &s
}

// Channel returns the value of the "channel" field in the mutation.
func (m *UserMutation) Channel() (r string, exists bool) {
	v := m.channel
	if v == nil {
		return
	}
	return *v, true
}

// OldChannel returns the old "channel" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannel: %w", err)
	}
	return oldValue.Channel, nil
}

// ResetChannel resets all changes to the "channel" field.
func (m *UserMutation) ResetChannel() {
	m.channel = nil
}

// SetRoleID sets the "role_id" field.
func (m *UserMutation) SetRoleID(u uint8) {
	m.role_id = &u
	m.addrole_id = nil
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserMutation) RoleID() (r uint8, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRoleID(ctx context.Context) (v uint8, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// AddRoleID adds u to the "role_id" field.
func (m *UserMutation) AddRoleID(u int8) {
	if m.addrole_id != nil {
		*m.addrole_id += u
	} else {
		m.addrole_id = &u
	}
}

// AddedRoleID returns the value that was added to the "role_id" field in this mutation.
func (m *UserMutation) AddedRoleID() (r int8, exists bool) {
	v := m.addrole_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserMutation) ResetRoleID() {
	m.role_id = nil
	m.addrole_id = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.channel != nil {
		fields = append(fields, user.FieldChannel)
	}
	if m.role_id != nil {
		fields = append(fields, user.FieldRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldChannel:
		return m.Channel()
	case user.FieldRoleID:
		return m.RoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldChannel:
		return m.OldChannel(ctx)
	case user.FieldRoleID:
		return m.OldRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannel(v)
		return nil
	case user.FieldRoleID:
		v, ok := value.(uint8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addrole_id != nil {
		fields = append(fields, user.FieldRoleID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldRoleID:
		return m.AddedRoleID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldRoleID:
		v, ok := value.(int8)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldChannel:
		m.ResetChannel()
		return nil
	case user.FieldRoleID:
		m.ResetRoleID()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
